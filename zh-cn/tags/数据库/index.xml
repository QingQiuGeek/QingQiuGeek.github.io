<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>数据库 on 青秋博客</title>
        <link>/zh-cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
        <description>Recent content in 数据库 on 青秋博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>青秋博客</copyright>
        <lastBuildDate>Thu, 26 Dec 2024 14:43:23 +0000</lastBuildDate><atom:link href="/zh-cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>MySQL入门概述</title>
        <link>/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/</link>
        <pubDate>Thu, 26 Dec 2024 14:43:23 +0000</pubDate>
        
        <guid>/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;MySQL 是建立在关系模型基础上的关系型数据库，关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;字段类型&#34;&gt;&lt;a href=&#34;#%e5%ad%97%e6%ae%b5%e7%b1%bb%e5%9e%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;字段类型
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image.png&#34;
	width=&#34;1654&#34;
	height=&#34;1426&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image_hu_8d67505423ab9cf5.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image_hu_fe9bc902be500416.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;115&#34;
		data-flex-basis=&#34;278px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;TINYINT 占 1 字节，INT 占 4 字节，BIGINT 占 8 字节。&lt;/li&gt;
&lt;li&gt;CHAR 是定长字符串，VARCHAR 是变长字符串。CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR 在存储时需要使用 1 或 2 个额外&lt;strong&gt;字节&lt;/strong&gt; 记录字符串的长度，检索时不需要处理。&lt;strong&gt;CHAR（100）指的是 100 个字符而非字节&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MySQL 中字符的存储是与字符集（&lt;code&gt;CHARSET&lt;/code&gt;）相关的，具体的字节数取决于你使用的字符集和编码。 &lt;strong&gt;&lt;code&gt;latin1&lt;/code&gt;&lt;/strong&gt; 编码（单字节编码），每个字符占用 &lt;strong&gt;1 字节&lt;/strong&gt; 。&lt;strong&gt;&lt;code&gt;utf8mb4&lt;/code&gt;&lt;/strong&gt; 编码（变长编码），每个字符可能占用 &lt;strong&gt;1 到 4 字节&lt;/strong&gt;，具体取决于字符的内容。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;varchar100和-varchar10区别&#34;&gt;&lt;a href=&#34;#varchar100%e5%92%8c-varchar10%e5%8c%ba%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;VARCHAR(100)和 VARCHAR(10)区别
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;VARCHAR(100)和 VARCHAR(10)都是变长类型，表示能存储最多 100 个字符和 10 个字符。但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，其所占用的磁盘空间是基于&lt;strong&gt;实际存储的字符长度&lt;/strong&gt;，而不是字段的最大长度。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;decimal-和-floatdouble-区别&#34;&gt;&lt;a href=&#34;#decimal-%e5%92%8c-floatdouble-%e5%8c%ba%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;DECIMAL 和 FLOAT/DOUBLE 区别
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;DECIMAL 是定点数，可以存储精确的小数值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FLOAT（4 字节），DOUBLE（8 字节） 是浮点数，只能存储近似的小数值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;text-和-blob&#34;&gt;&lt;a href=&#34;#text-%e5%92%8c-blob&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;TEXT 和 BLOB
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;TEXT 可以存储更长的字符串，即长文本数据，例如博客内容。&lt;/li&gt;
&lt;li&gt;BLOB 类型主要用于存储二进制大对象，例如图片、音视频等文件。&lt;/li&gt;
&lt;li&gt;TEXT 和 BLOB 缺点：
&lt;ul&gt;
&lt;li&gt;不能有默认值。&lt;/li&gt;
&lt;li&gt;检索效率较低。&lt;/li&gt;
&lt;li&gt;在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表。&lt;/li&gt;
&lt;li&gt;不能直接创建索引，需要指定前缀长度。
&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-1.png&#34;
	width=&#34;990&#34;
	height=&#34;449&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-1_hu_dada62f7d2c52a32.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-1_hu_423eb2c7607370a0.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;220&#34;
		data-flex-basis=&#34;529px&#34;
	
&gt; &amp;gt; &lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-2.png&#34;
	width=&#34;999&#34;
	height=&#34;457&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-2_hu_8d460f34bb7ae061.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-2_hu_5cff2a90b8be2234.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;218&#34;
		data-flex-basis=&#34;524px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;datetime-和-timestamp&#34;&gt;&lt;a href=&#34;#datetime-%e5%92%8c-timestamp&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;DATETIME 和 TIMESTAMP
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html#%E6%97%B6%E5%8C%BA%E4%BF%A1%E6%81%AF&#34;  title=&#34;MySQL日期类型选择建议 | JavaGuide&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL 日期类型选择建议 | JavaGuide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。
&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-3.png&#34;
	width=&#34;1594&#34;
	height=&#34;614&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-3_hu_38c6b5a7aa80305.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-3_hu_618882815bdb491b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;259&#34;
		data-flex-basis=&#34;623px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;null-和的区别&#34;&gt;&lt;a href=&#34;#null-%e5%92%8c%e7%9a%84%e5%8c%ba%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;NULL 和&amp;quot;&amp;ldquo;的区别
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NULL&lt;/code&gt; 代表一个不确定的值,就算是两个 &lt;code&gt;NULL&lt;/code&gt;,它俩也不一定相等。例如，&lt;code&gt;SELECT NULL=NULL&lt;/code&gt;的结果为 NULL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;&#39;&lt;/code&gt;的长度是 0，是不占用空间的，而&lt;code&gt;NULL&lt;/code&gt; 是需要占用空间&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;为什么-mysql-不建议使用-null-作为列默认值&#34;&gt;&lt;a href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88-mysql-%e4%b8%8d%e5%bb%ba%e8%ae%ae%e4%bd%bf%e7%94%a8-null-%e4%bd%9c%e4%b8%ba%e5%88%97%e9%bb%98%e8%ae%a4%e5%80%bc&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;为什么 MySQL 不建议使用 &lt;code&gt;NULL&lt;/code&gt; 作为列默认值?
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt; 会影响聚合函数的结果。例如，&lt;code&gt;SUM&lt;/code&gt;、&lt;code&gt;AVG&lt;/code&gt;、&lt;code&gt;MIN&lt;/code&gt;、&lt;code&gt;MAX&lt;/code&gt; 等聚合函数会忽略 &lt;code&gt;NULL&lt;/code&gt; 值，如果参数是某个字段名(&lt;code&gt;COUNT(列名)&lt;/code&gt;)，则会忽略 &lt;code&gt;NULL&lt;/code&gt; 值，只统计非空值的个数。查询 &lt;code&gt;NULL&lt;/code&gt; 值时，必须使用 &lt;code&gt;IS NULL&lt;/code&gt; 或 &lt;code&gt;IS NOT NULLl&lt;/code&gt; 来判断，而不能使用 =、!=、 &amp;lt;、&amp;gt; 之类的比较运算符。而&lt;code&gt;&#39;&#39;&lt;/code&gt;是可以使用这些比较运算符的。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;boolean-类型如何表示&#34;&gt;&lt;a href=&#34;#boolean-%e7%b1%bb%e5%9e%8b%e5%a6%82%e4%bd%95%e8%a1%a8%e7%a4%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Boolean 类型如何表示
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;mysql-基础架构&#34;&gt;&lt;a href=&#34;#mysql-%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;MySQL 基础架构
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-4.png&#34;
	width=&#34;1437&#34;
	height=&#34;1088&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-4_hu_703d27ddae52e213.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-4_hu_a495e2d79e84f504.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;132&#34;
		data-flex-basis=&#34;316px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连接器：&lt;/strong&gt; 身份认证和权限相关(登录 MySQL 的时候)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查询缓存：&lt;/strong&gt; 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分析器：&lt;/strong&gt; 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化器：&lt;/strong&gt; 按照 MySQL 认为最优的方案去执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行器：&lt;/strong&gt; 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插件式存储引擎&lt;/strong&gt; ：主要负责数据的存储和读取，采用的是&lt;strong&gt;插件式架构&lt;/strong&gt;，支持 InnoDB、MyISAM、Memory 等多种存储引擎。InnoDB 是 MySQL 的默认存储引擎，绝大部分场景使用 InnoDB 就是最好的选择。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;mysql-存储引擎&#34;&gt;&lt;a href=&#34;#mysql-%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;MySQL 存储引擎
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html&#34;  title=&#34;MySQL :: MySQL 8.0 Reference Manual :: 17 The InnoDB Storage Engine&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL :: MySQL 8.0 Reference Manual :: 17 The InnoDB Storage Engine&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html&#34;  title=&#34;MySQL :: MySQL 8.0 Reference Manual :: 18 Alternative Storage Engines&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL :: MySQL 8.0 Reference Manual :: 18 Alternative Storage Engines&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-5.png&#34;
	width=&#34;2152&#34;
	height=&#34;538&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-5_hu_2c6352c126711b07.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-5_hu_58ed7189f3e90260.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;400&#34;
		data-flex-basis=&#34;960px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。 在上述所有引擎中，&lt;strong&gt;只有 InnoDB 引擎支持事务。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;上面还提到过 MySQL 存储引擎采用的是 &lt;strong&gt;插件式架构&lt;/strong&gt; ，支持多种存储引擎。&lt;strong&gt;存储引擎是基于表的，而不是数据库。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;myisam-和-innodb-区别&#34;&gt;&lt;a href=&#34;#myisam-%e5%92%8c-innodb-%e5%8c%ba%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;MyISAM 和 InnoDB 区别
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;锁：&lt;/strong&gt; MyISAM 只有表级锁，而 InnoDB 支持行级锁和表级锁，默认为行级锁。对于并发操作，细粒度的行级锁性能肯定更好！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事务：&lt;/strong&gt;
MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了四个隔离级别，分别是：&lt;strong&gt;读未提交、读已提交、可重复读、可串行化&lt;/strong&gt;。InnoDB 默认是可重读，隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;外键：&lt;/strong&gt; MyISAM 不支持物理外键，而 InnoDB 支持物理外键。然而外键的维护对数据库性能也有一定影响，特别是分布式、高并发项目，一个字段的更新往往会引起其他字段的更新，极大拉低数据库性能，因此是不建议使用物理外键，而是逻辑外键（在代码中进行约束）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据恢复&lt;/strong&gt; ：MyISAM 不支持，而 InnoDB 支持。使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候依赖&lt;strong&gt;redo.log&lt;/strong&gt;使数据库恢复到崩溃前的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MVCC：&lt;/strong&gt; MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。MyISAM 显然是不支持 MVCC 的，毕竟连行级锁都没有。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;索引：&lt;/strong&gt; 都使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据缓存策略和机制：&lt;/strong&gt; InnoDB 使用缓冲池（Buffer Pool）缓存数据页和索引页，MyISAM 使用键缓存（Key Cache）仅缓存索引页而不缓存数据页。当数据库对数据做修改的时候，需要把数据页从磁盘读到 buffer pool 中，&lt;strong&gt;然后在 buffer pool 中进行修改&lt;/strong&gt; ，此时 buffer pool 中的数据页就与磁盘上的数据页&lt;strong&gt;内容不一致&lt;/strong&gt;，如果这个时候发生 DB 服务重启，那么这些数据并没有同步到磁盘文件中（同步到磁盘文件是个随机 IO），就会发生数据丢失，如果这个时候，能够在有一个文件，当 buffer pool 中的数据页变更结束后，把相应修改记录记录到这个文件（记录日志是顺序 IO），那么当 DB 服务进行恢复 DB 的时候，可以根据这个文件的记录内容，重新持久化刷新到磁盘文件，保持数据的一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能：&lt;/strong&gt; InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的&lt;strong&gt;读写能力呈线性增长&lt;/strong&gt;。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-6.png&#34;
	width=&#34;1606&#34;
	height=&#34;549&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-6_hu_66e9c13c13f7c56c.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-6_hu_41924396b50195ff.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;292&#34;
		data-flex-basis=&#34;702px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;mysql-如何存储-ip-地址&#34;&gt;&lt;a href=&#34;#mysql-%e5%a6%82%e4%bd%95%e5%ad%98%e5%82%a8-ip-%e5%9c%b0%e5%9d%80&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;MySQL 如何存储 IP 地址
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;可以使用字符串存储，但是存储空间相对较大（每个字符占用 1 字节），每个 IP 占用空间为 7-15 个字节（1.1.1.1 占用 7 字节，100.100.100.100 占用 15 字节）。&lt;/p&gt;
&lt;p&gt;对于 ipv4，其实是 4 字节 32 位的数字，可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。&lt;/p&gt;
&lt;p&gt;MySQL 提供了两个方法来处理 ip 地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;INET_ATON()&lt;/code&gt;：把 ip 转为无符号整型 (4-8 位)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INET_NTOA()&lt;/code&gt; :把整型的 ip 转为地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;插入数据前，先用 &lt;code&gt;INET_ATON()&lt;/code&gt; 把 ip 地址转为整型，显示数据时，使用 &lt;code&gt;INET_NTOA()&lt;/code&gt; 把整型的 ip 地址转为地址显示即可。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
