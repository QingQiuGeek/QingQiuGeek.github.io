<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>数据库 on 青秋博客</title>
        <link>/zh-cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
        <description>Recent content in 数据库 on 青秋博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>青秋博客</copyright>
        <lastBuildDate>Sun, 16 Feb 2025 12:38:15 +0000</lastBuildDate><atom:link href="/zh-cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Spring事务失效的几种场景</title>
        <link>/zh-cn/post/2025/02/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF/</link>
        <pubDate>Sun, 16 Feb 2025 12:38:15 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/02/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF/</guid>
        <description>&lt;p&gt;&lt;strong&gt;1. 未启用 Spring 事务管理功能或 bean 没有被 spring 管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. @Transactional 修饰的方法非 public 或被 final、static 修饰&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 同类的方法 A 直接调用同类的事务方法 B&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;spring 事务是通过 Spring AOP 实现的，&lt;/strong&gt; 对需要 spring 管理事务的 bean 生成了代理对象，然后通过代理对象拦截了目标方法的执行，在&lt;strong&gt;方法前后&lt;/strong&gt; 添加了事务的功能，所以&lt;strong&gt;必须通过代理对象调用&lt;/strong&gt; 目标方法的时候，事务才会起效。如果方法 A 直接调用方法 B 则是 this 调用，即该类的类对象，就不是代理对象。可以通过&lt;code&gt;Service&lt;/code&gt; 类中注入自己，或者通过&lt;code&gt;AopContext.currentProxy()&lt;/code&gt;获取代理对象来解决。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;4. 抛出的异常类型错误&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在业务方法进行异常抛出，spring 会自动对事务进行回滚，那么问题来了，抛出哪些异常 spring 会回滚事务呢？&lt;strong&gt;默认情况下，spring 遇到 RuntimeException 和 Error 的事务才会回滚。因为 spring 认为 RuntimeException 和 Error 是不可预期的错误，而受检异常是可预期的错误，可以通过业务逻辑即可解决。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然也可以自定义回滚异常类型@Transactional(rollbackFor = {异常类型列表})&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;5. 异常被捕获处理&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;spring 感知到指定异常被抛出才会进行回滚，如果在方法内部捕获处理掉异常，事务就不会回滚&lt;/p&gt;&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Transactional&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;m1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;事务操作1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;try&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;事务操作2&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;内部抛出了异常&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(....)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;正确做法是捕获处理掉异常后抛出来，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Transactional&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;m1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;事务操作1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;try&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;事务操作2&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;内部抛出了异常&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(....)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;6. 事务操作和@Transactional 方法不在同一线程&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Transactional&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;m1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;一系列事务操作&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;7. 事务传播行为设置不对&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;spring 默认事务传播行为默认是**required，事务方法 A 内部调用事务方法 B，**如果方法 A 存在事务则方法 B 加入方法 A 的事务，否则创建新事务。如果非事务方法 A 调用事务方法 B，事务传播级别为 NOT_SUPPORT，因为方法 A 当前不存在事务，则方法 B 虽然有@Transactional 注解，但仍然以非事务去执行。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>Mysql索引失效的几种场景、回表、索引覆盖、索引下推</title>
        <link>/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/</link>
        <pubDate>Sat, 15 Feb 2025 10:33:28 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/</guid>
        <description>&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;按「数据结构」分类：B+tree 索引、Hash 索引、Full-text 索引。&lt;/li&gt;
&lt;li&gt;按「物理存储」分类：聚簇索引（主键索引）、非聚簇索引（二级索引、辅助索引）。&lt;/li&gt;
&lt;li&gt;按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。&lt;/li&gt;
&lt;li&gt;按「字段个数」分类：单列索引、联合索引。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;聚簇索引和二级索引&#34;&gt;&lt;a href=&#34;#%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e5%92%8c%e4%ba%8c%e7%ba%a7%e7%b4%a2%e5%bc%95&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;聚簇索引和二级索引
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;innodb 使用 b+树作为索引数据结构。在创建表时，InnoDB &lt;strong&gt;默认会创建一个主键索引（primary key），也就是聚簇索引，而其它索引都属于二级索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果没有指明主键索引，就自动在后台创建 &lt;strong&gt;隐藏的 6 字节 row_id 列&lt;/strong&gt; 作为主键索引。&lt;/p&gt;
&lt;p&gt;值得一提的是，InnoDB 和 MyISAM 都支持 B+树索引，但是它们数据的存储结构实现方式不同。InnoDB 存储擎的 B+树索引的叶子节点保存数据本身（图 1），MylSAM 存储引擎的 B+树索引的叶子节点保存数据的物理地址（图 2）；&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image.png&#34;
	width=&#34;1080&#34;
	height=&#34;633&#34;
	srcset=&#34;/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image_hu_71e86be3883abdc8.png 480w, /zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image_hu_8fc3667f7bd5df4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;170&#34;
		data-flex-basis=&#34;409px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image-1.png&#34;
	width=&#34;914&#34;
	height=&#34;569&#34;
	srcset=&#34;/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image-1_hu_cca700ad0675f431.png 480w, /zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image-1_hu_97c6a84ec1ec53f5.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;160&#34;
		data-flex-basis=&#34;385px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;InnoDB 存储引擎根据索引类型不同，分为聚簇索引（图 1）和二级索引。区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户数据都存放在聚簇索引的叶子节点，而&lt;strong&gt;二级索引的叶子节点存放的是主键值，而不是实际数据&lt;/strong&gt;。如果将 name 字段设置为普通索引，那么这个&lt;strong&gt;二级索引&lt;/strong&gt;长下图这样：&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image-2.png&#34;
	width=&#34;1676&#34;
	height=&#34;872&#34;
	srcset=&#34;/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image-2_hu_2941517050fef206.png 480w, /zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image-2_hu_ad4f09b55f9cabec.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;192&#34;
		data-flex-basis=&#34;461px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;回表和索引覆盖&#34;&gt;&lt;a href=&#34;#%e5%9b%9e%e8%a1%a8%e5%92%8c%e7%b4%a2%e5%bc%95%e8%a6%86%e7%9b%96&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;回表和索引覆盖  
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果使用主键索引作为条件查询&lt;/strong&gt;，查询&lt;strong&gt;聚簇索引&lt;/strong&gt;的叶子节点数据（图 1），那么就直接在叶子节点读取到要查询的数据，比如 select * from user where id=1 (id 是主键索引)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果使用二级索引字段作为条件查询&lt;/strong&gt;，查询&lt;strong&gt;聚簇索引&lt;/strong&gt;的叶子节点数据，那么需要检索两颗 B+树：&lt;br&gt;
先在二级索引的 B+树找到对应的叶子节点，获取主键值（图 3），然后用获取的主键值，在聚簇索引中的 B+树检索到对应的叶子节点（图 1），然后获取要查询的数据。这个过程叫做&lt;strong&gt;回表&lt;/strong&gt;，如 select * from user where name=&amp;ldquo;林某&amp;rdquo;（name 是二级索引）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果使用二级索引字段作为条件查询&lt;/strong&gt;，&lt;strong&gt;查询二级索引的叶子节点数据&lt;/strong&gt;（图 3），那么只需在二级索引的 B+ 树找到对应的叶子节点，然后读取要查询的数据，不需要用到主键索引，这个过程叫做&lt;strong&gt;覆盖索引&lt;/strong&gt;。如 select id from user where name=&amp;ldquo;林某&amp;rdquo;（name 是二级索引，id 正好存在于二级索引中）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;索引失效场景&#34;&gt;&lt;a href=&#34;#%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e5%9c%ba%e6%99%af&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;索引失效场景
&lt;/h2&gt;&lt;h3 id=&#34;like-xx-或-like-xx&#34;&gt;&lt;a href=&#34;#like-xx-%e6%88%96-like-xx&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;like %xx 或 like %xx%
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。&lt;strong&gt;对索引使用左或左右模糊匹配，此时会走&lt;/strong&gt;全表扫描&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;对索引使用函数&#34;&gt;&lt;a href=&#34;#%e5%af%b9%e7%b4%a2%e5%bc%95%e4%bd%bf%e7%94%a8%e5%87%bd%e6%95%b0&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;对索引使用函数
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;select * from user where length(name)=3（name 是二级索引），因为索引保存的是索引字段原始值，而不是经过函数计算后的值，自然就没办法走索引了而是全表扫描。&lt;/p&gt;
&lt;p&gt;不过，从 MySQL8.0 开始，索引特性增加了函数索引，可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;对索引表达式计算&#34;&gt;&lt;a href=&#34;#%e5%af%b9%e7%b4%a2%e5%bc%95%e8%a1%a8%e8%be%be%e5%bc%8f%e8%ae%a1%e7%ae%97&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;对索引表达式计算
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;select * from from where id +1=10 会走全表扫描，因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，而 select * from from where id = 10 -1 则会走索引查询。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;对索引隐式类型转换&#34;&gt;&lt;a href=&#34;#%e5%af%b9%e7%b4%a2%e5%bc%95%e9%9a%90%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;对索引隐式类型转换
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话就会走全表扫描，而如果反过来，索引字段是整型，查询参数是字符串，此时会走索引，**因为 mysql 在字符串和整型比较时会自动把字符串变成数字，**所以字符串类型的索引，在使用整型参数查询时，还得把字符串索引变成整型才行，也就相当于调用了函数。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;联合索引不满足最左匹配&#34;&gt;&lt;a href=&#34;#%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95%e4%b8%8d%e6%bb%a1%e8%b6%b3%e6%9c%80%e5%b7%a6%e5%8c%b9%e9%85%8d&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;联合索引不满足最左匹配
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。那么**多个普通字段组合在一起创建的索引就叫做联合索引（组合索引），**在使用联合索引时要遵循最左匹配，比如创建联合索引（a,b,c），查询时 where b=1；where c=3；where b=2 and c=3；这三种情况都会使联合索引失效。&lt;/p&gt;
&lt;p&gt;有一个比较特殊的查询条件：&lt;strong&gt;where a = 1 and c = 3&lt;/strong&gt;，这属于&lt;strong&gt;索引截断&lt;/strong&gt;，不同版本处理方式也不一样。MySQL5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行交给 Server 层，在 Server 层再比对 c 字段的值。从 MySQL5.6 之后，有一个&lt;strong&gt;索引下推&lt;/strong&gt;，即在存储引擎层进行索引遍历时，对索引中包含的字段先做判断（a 和 c 都在索引中），直接过滤掉不满足条件的记录，再返还给 Server 层，从而&lt;strong&gt;减少回表次数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然&lt;strong&gt;回表只发生在用二级索引查询聚簇索引的数据&lt;/strong&gt;，如果用主键索引查聚簇索引的数据就不存在回表了。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;索引下推原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在(a,b,c)联合索引里的)，然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。&lt;/p&gt;
&lt;p&gt;没索引下推：存储引擎先定位到第一条 a=1 的数据，然后拿着其主键去回表，读取出数据给 server 层，然后 server 层判断是否满足 c=3，来决定是否给客户端，然后存储引擎重复上面操作，反复回表。&lt;br&gt;
有索引下推:    就直接在存储引擎层过滤，减少回表操作。&lt;/p&gt;
&lt;p&gt;联合索引的匹配遵循  &lt;strong&gt;最左前缀原则&lt;/strong&gt;，且  &lt;strong&gt;从最左列开始按顺序匹配&lt;/strong&gt;。当遇到第一个范围查询时，&lt;strong&gt;后续列的索引将不再生效&lt;/strong&gt;；而等值查询则允许后续列继续匹配索引，直到遇到范围查询为止。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;where-中使用-or&#34;&gt;&lt;a href=&#34;#where-%e4%b8%ad%e4%bd%bf%e7%94%a8-or&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;where 中使用 or
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在 WHERE 子句中，如果  OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;两个索引列做比较&#34;&gt;&lt;a href=&#34;#%e4%b8%a4%e4%b8%aa%e7%b4%a2%e5%bc%95%e5%88%97%e5%81%9a%e6%af%94%e8%be%83&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;两个索引列做比较
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 的索引（如 B+Tree 索引）是&lt;strong&gt;按列值单独排序&lt;/strong&gt;的。每个索引独立存储某列的值及其行位置（ROWID）。当比较两列时：&lt;/p&gt;
&lt;p&gt;若使用  &lt;code&gt;column1&lt;/code&gt;  的索引，只能快速定位到  &lt;code&gt;column1&lt;/code&gt;  的特定值，但无法直接关联到  &lt;code&gt;column2&lt;/code&gt;  的值。同理，&lt;code&gt;column2&lt;/code&gt;  的索引也无法关联到  &lt;code&gt;column1&lt;/code&gt;  的值。优化器无法通过索引直接找到满足  &lt;code&gt;column1 = column2&lt;/code&gt;  的行，只能通过全表扫描逐行比较。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;不等于比较&#34;&gt;&lt;a href=&#34;#%e4%b8%8d%e7%ad%89%e4%ba%8e%e6%af%94%e8%be%83&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;不等于比较
&lt;/h3&gt;&lt;h3 id=&#34;is-not-null&#34;&gt;&lt;a href=&#34;#is-not-null&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;is not null
&lt;/h3&gt;&lt;h3 id=&#34;not-in-和-not-exists&#34;&gt;&lt;a href=&#34;#not-in-%e5%92%8c-not-exists&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;not in 和 not exists
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;查询条件使用 not in 时，如果是主键索引则走索引，如果是普通索引，则索引失效。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;order-by&#34;&gt;&lt;a href=&#34;#order-by&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;order by
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对索引 order by 导致全表排序&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>【已解决】redisCache注解失效，没写cacheConfig</title>
        <link>/zh-cn/post/2025/01/%E5%B7%B2%E8%A7%A3%E5%86%B3rediscache%E6%B3%A8%E8%A7%A3%E5%A4%B1%E6%95%88%E6%B2%A1%E5%86%99cacheconfig/</link>
        <pubDate>Sat, 25 Jan 2025 12:00:00 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/01/%E5%B7%B2%E8%A7%A3%E5%86%B3rediscache%E6%B3%A8%E8%A7%A3%E5%A4%B1%E6%95%88%E6%B2%A1%E5%86%99cacheconfig/</guid>
        <description>&lt;h2 id=&#34;环境配置&#34;&gt;&lt;a href=&#34;#%e7%8e%af%e5%a2%83%e9%85%8d%e7%bd%ae&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;环境配置
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;jdk11、SpringBoot 2.6.13&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&#34;nt&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span class=&#34;nt&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.2.0&lt;span class=&#34;nt&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&#34;nt&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-cache&lt;span class=&#34;nt&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.2.0&lt;span class=&#34;nt&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;192.168.2.129&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;username&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;linux02&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;database&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;#    默认使用lettuce&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;lettuce&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;pool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;#        最大连接数，最大空闲数，最小空闲数&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;max-active&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;max-idle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;min-idle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;#    缓存10min，允许缓存null值防止缓存穿透&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;time-to-live&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;600&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cache-null-values&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;代码&#34;&gt;&lt;a href=&#34;#%e4%bb%a3%e7%a0%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;代码
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Cacheable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cacheNames&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BLOG_CACHE_PREFIX&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;otherPassages&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;#userId&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PassageTitleVO&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getOtherPassagesByUserId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Long&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;userId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;....&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;....&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;passageTitleVOS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;解决&#34;&gt;&lt;a href=&#34;#%e8%a7%a3%e5%86%b3&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;解决
&lt;/h2&gt;&lt;p&gt;网上找了一些案例，有的不需要写 cacheConfig，有些需要写，我之前就用过 cacheable 的注解，当时就是上面的配置，没写配置类也有效果，这次我最开始就没写，然后 Cacheable 注解就没效果了，最后写了个 cacheConfig 才解决。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Configuration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@EnableCaching&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CacheConfig&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CachingConfigurerSupport&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Bean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisCacheManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;cacheManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisConnectionFactory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisConnectionFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisCacheManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisConnectionFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后又发现 yml 设置的过期时间没有生效，存到 redis 的是永不过期，又在 cacheConfig 配置了过期时间，600s&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Configuration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@EnableCaching&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CacheConfig&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CachingConfigurerSupport&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Bean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisCacheManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;cacheManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisConnectionFactory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisConnectionFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisCacheConfiguration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisCacheConfiguration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisCacheConfiguration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;defaultCacheConfig&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;entryTtl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Duration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ofSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;600&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisCacheManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisConnectionFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;cacheDefaults&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisCacheConfiguration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
</description>
        </item>
        <item>
        <title>MySQL三大日志</title>
        <link>/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/</link>
        <pubDate>Fri, 24 Jan 2025 21:03:52 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;常见的 mysql 日志有二进制日志 binlog（归档日志）和重做日志 redo log（事务日志）和 undo log（回滚日志）。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image.png&#34;
	width=&#34;1407&#34;
	height=&#34;310&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image_hu_c5edda36ce4b3de7.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image_hu_77625b95d3216b77.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;453&#34;
		data-flex-basis=&#34;1089px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;undo-log-回滚日志&#34;&gt;&lt;a href=&#34;#undo-log-%e5%9b%9e%e6%bb%9a%e6%97%a5%e5%bf%97&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;undo log 回滚日志
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;undo log 保证了事务的原子性&lt;/strong&gt;，undo log 的信息也会被记录到 redo log 中，因为 undo log 也要实现持久性保护。&lt;br&gt;
每当 innoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在插入一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录删掉就好了；&lt;/li&gt;
&lt;li&gt;在删除一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了；&lt;/li&gt;
&lt;li&gt;在更新一条记录时，要把被更新的列的旧值记下来，这祥样之后回滚时再把这些列更新为旧值就好了。
&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-1.png&#34;
	width=&#34;352&#34;
	height=&#34;571&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-1_hu_e088fd4123d60716.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-1_hu_7ddca99daf083009.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;61&#34;
		data-flex-basis=&#34;147px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;readviewundo-log-实现-mvcc&#34;&gt;&lt;a href=&#34;#readviewundo-log-%e5%ae%9e%e7%8e%b0-mvcc&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;ReadView+undo log 实现 MVCC
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在读已提交和可重复读的隔离级别，普通读是通过 ReadView+undo log 实现的
&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-2.png&#34;
	width=&#34;1411&#34;
	height=&#34;628&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-2_hu_fb1f02189ebebcf3.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-2_hu_1afbf579a2a402a.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;224&#34;
		data-flex-basis=&#34;539px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;buffer-pool&#34;&gt;&lt;a href=&#34;#buffer-pool&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Buffer Pool
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 的数据都是存在磁盘中的，那么更新一条记录的时候，得先要从磁盘读取该&lt;br&gt;
记录，然后在内存中修改这条记录。&lt;strong&gt;那修改完这条记录是选择直接写回到磁盘，还是选择缓存起来呢？&lt;/strong&gt;&lt;br&gt;
当然是缓存起来好，这样下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了。为此，Innodb 存储引擎设计了一个 Buffer Pool，来提高数据库的读写性能。当修改数据时，&lt;strong&gt;如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页&lt;/strong&gt;（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘 IO，不会立即将脏页写入磁盘，后续由后台线程选择一个&lt;strong&gt;合适的时机&lt;/strong&gt;将脏页写入到磁盘。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;redo-log-重做日志&#34;&gt;&lt;a href=&#34;#redo-log-%e9%87%8d%e5%81%9a%e6%97%a5%e5%bf%97&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;redo log 重做日志
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 中数据是以页为单位，查询一条记录会&lt;strong&gt;从硬盘把一页的数据加载出来&lt;/strong&gt;，加载出来的数据叫&lt;strong&gt;数据页&lt;/strong&gt;，会放入到 &lt;strong&gt;&lt;code&gt;Buffer Pool&lt;/code&gt;&lt;/strong&gt; 中。&lt;/p&gt;
&lt;p&gt;后续的查询都是先从 &lt;code&gt;Buffer Pool&lt;/code&gt; 中找，没有命中再去硬盘加载，&lt;strong&gt;减少硬盘 IO 开销&lt;/strong&gt;，提升性能。&lt;/p&gt;
&lt;p&gt;更新表数据的时候，也是先更新&lt;code&gt;Buffer Pool&lt;/code&gt; 的数据，如果没有则先把数据读到&lt;code&gt;Buffer Pool&lt;/code&gt;&lt;strong&gt;。&lt;strong&gt;然后会把“在某个数据页上做了什么修改”记录到&lt;code&gt;redo log buffer&lt;/code&gt;，接着&lt;/strong&gt;刷盘到 redo log&lt;/strong&gt; 文件里。
&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-3.png&#34;
	width=&#34;1234&#34;
	height=&#34;724&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-3_hu_f42a7e1a8f01dc.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-3_hu_9764915eb673c85c.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;170&#34;
		data-flex-basis=&#34;409px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;那么&lt;strong&gt;什么时候会进行刷盘&lt;/strong&gt;呢？别急，往后看！&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;为什么需要-redo-log&#34;&gt;&lt;a href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-redo-log&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;为什么需要 redo log
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为了防止 buffer pool 的脏页丢失而设计&lt;/strong&gt;。buffer pool 基于内存，提高了 mysql 性能，但是内存的数据没有持久化到磁盘，mysql 宕机后会数据丢失，为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会**先更新内存并标记为脏页，然后将本次对页的修改以 redo log 的形式记录下&lt;br&gt;
来，**这个时候更新就算完成了。&lt;br&gt;
后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘&lt;br&gt;
里，这就是 WAL(Write-Ahead Logging)技术。WAL 技术指的是，MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。
&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-4.png&#34;
	width=&#34;1292&#34;
	height=&#34;977&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-4_hu_b38e36e8563d6c3e.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-4_hu_d15426903c5875b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;132&#34;
		data-flex-basis=&#34;317px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;刷盘时机&#34;&gt;&lt;a href=&#34;#%e5%88%b7%e7%9b%98%e6%97%b6%e6%9c%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;刷盘时机
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;事务提交：当事务提交时，log buffer 里的 redo log 会被刷新到磁盘（可以通过&lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;参数控制，后文会提到）。&lt;/li&gt;
&lt;li&gt;log buffer 空间不足时：log buffer 中缓存的 redo log 已经占满了 log buffer 总容量的大约&lt;strong&gt;一半&lt;/strong&gt;左右，就需要把这些日志刷新到磁盘上。&lt;/li&gt;
&lt;li&gt;Checkpoint（检查点）：InnoDB 定期会执行检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。&lt;/li&gt;
&lt;li&gt;后台刷新线程：InnoDB 启动了一个后台线程，负责周期性（每隔 1 秒）地将脏页（已修改但尚未写入磁盘的数据页）fsync 刷新到磁盘，并将相关的重做日志一同刷新。&lt;/li&gt;
&lt;li&gt;正常关闭服务器：MySQL 关闭的时候，redo log 都会刷入到磁盘里去。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;redo-log-要写到磁盘数据也要写磁盘为什么要多此一举&#34;&gt;&lt;a href=&#34;#redo-log-%e8%a6%81%e5%86%99%e5%88%b0%e7%a3%81%e7%9b%98%e6%95%b0%e6%8d%ae%e4%b9%9f%e8%a6%81%e5%86%99%e7%a3%81%e7%9b%98%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%a4%9a%e6%ad%a4%e4%b8%80%e4%b8%be&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;写入 redo log 的方式使用了追加操作，是顺序写，而磁盘写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。「顺序写」比「随机写」高效的多，因此 redo log 写入磁盘的开销更小。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;修改数据页后脏页为何不直接刷盘还需要-redo-log&#34;&gt;&lt;a href=&#34;#%e4%bf%ae%e6%94%b9%e6%95%b0%e6%8d%ae%e9%a1%b5%e5%90%8e%e8%84%8f%e9%a1%b5%e4%b8%ba%e4%bd%95%e4%b8%8d%e7%9b%b4%e6%8e%a5%e5%88%b7%e7%9b%98%e8%bf%98%e9%9c%80%e8%a6%81-redo-log&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;修改数据页后（脏页）为何不直接刷盘，还需要 redo log
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;数据页大小是 16kb，刷盘（&lt;strong&gt;随机写&lt;/strong&gt;）要进行 io 比较耗时，如果仅修改了数据页几 byte 的数据，没必要刷盘。而写 red log  一行记录（&lt;strong&gt;顺序写&lt;/strong&gt;）可能就占几十  &lt;code&gt;Byte&lt;/code&gt;，相对来说更优。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;redolog 采用循环写，边写边擦除日志，只记录未被刷入磁盘的数据 ，已刷入磁盘的数据会从 redolog 中擦除，而 binlog 保存的全量日志，如果整个数据库都删除了，可以用 binlog 恢复数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了，这时候擦除这些旧记录，以腾出空间记录新的更新操作。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-5.png&#34;
	width=&#34;1335&#34;
	height=&#34;495&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-5_hu_eaba9717e79ce6c5.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-5_hu_c0d652cd1a61c7d7.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;269&#34;
		data-flex-basis=&#34;647px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;bin-log-归档日志&#34;&gt;&lt;a href=&#34;#bin-log-%e5%bd%92%e6%a1%a3%e6%97%a5%e5%bf%97&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;bin log 归档日志
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;redo log 是&lt;strong&gt;物理日志&lt;/strong&gt;，记录内容是“&lt;strong&gt;在某个数据页上做了什么修改&lt;/strong&gt;”，属于 InnoDB 存储引擎。&lt;/p&gt;
&lt;p&gt;binlog 是&lt;strong&gt;逻辑日志&lt;/strong&gt;，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于&lt;code&gt;MySQL Server&lt;/code&gt;  层，会记录所有涉及更新数据的逻辑操作，并且是&lt;strong&gt;顺序写&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;binlog 日志有三种格式，由 binlog_format 指定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;statement&lt;br&gt;
记录 SQL 原文，这样同步数据时仅需执行 SQL 即可，但是如果 SQL 中有 now()，那么此时同步获取的时间和原库的时间是不一致的。因此在同步数据时，需要指定为 row 格式，不仅记录 SQL，还包含具体数据，即把 now()变成具体时间戳&lt;/li&gt;
&lt;li&gt;row&lt;br&gt;
记录 SQL 和具体数据，因此这种格式会占用更多的空间，恢复与同步时会更消耗 IO 资源，影响执行速度。&lt;/li&gt;
&lt;li&gt;mixed&lt;br&gt;
前两者混合&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;bin-log-刷盘时机&#34;&gt;&lt;a href=&#34;#bin-log-%e5%88%b7%e7%9b%98%e6%97%b6%e6%9c%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;bin log 刷盘时机  
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;事务执行过程中，先把日志 write 到&lt;code&gt;binlog cache&lt;/code&gt;，事务提交的时，再把&lt;code&gt;binlog cache fsync到&lt;/code&gt;binlog 文件中。&lt;/p&gt;
&lt;p&gt;因为一个事务的 binlog 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会&lt;strong&gt;给每个线程分配一个&lt;code&gt;binlog cache&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;binlog_cache_size&lt;/code&gt;参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（&lt;code&gt;Swap&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-6.png&#34;
	width=&#34;1238&#34;
	height=&#34;916&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-6_hu_92a3da250b4b9bbe.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-6_hu_2fc79d97a20919ec.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;135&#34;
		data-flex-basis=&#34;324px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;两阶段提交&#34;&gt;&lt;a href=&#34;#%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;两阶段提交
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在执行更新语句过程，会记录 redo log 与 binlog 两块日志，以基本的事务为单位，&lt;strong&gt;redo log&lt;/strong&gt; &lt;strong&gt;在事务执行过程中可以不断写入&lt;/strong&gt;，而 binlog 只有&lt;strong&gt;在提交事务时才写入&lt;/strong&gt;，所以 redo log 与 binlog 的写入时机不一样。&lt;br&gt;
如果在写完 redolog 日志后，binlog 日志写期间发生异常，就会导致数据不一致。对此 innodb 采用两阶段提交方案（XA 事务），把 redo log 写入拆成 prepare 和 commit 两阶段
&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-7.png&#34;
	width=&#34;1157&#34;
	height=&#34;842&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-7_hu_e2256c06902a886f.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-7_hu_95975fb7f15b9792.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;137&#34;
		data-flex-basis=&#34;329px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这样 binlog 写期间发生异常，redolog 还处于 prepare 阶段，回滚事务。&lt;br&gt;
而如果 binlog 期间无异常，commit 期间异常，就不会回滚事务，因为 binlog 日志已经记录成功，mysql 就认为是完整的，会提交事务恢复数据。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;异常重启出现什么现象&#34;&gt;&lt;a href=&#34;#%e5%bc%82%e5%b8%b8%e9%87%8d%e5%90%af%e5%87%ba%e7%8e%b0%e4%bb%80%e4%b9%88%e7%8e%b0%e8%b1%a1&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;异常重启出现什么现象
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-8.png&#34;
	width=&#34;1175&#34;
	height=&#34;842&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-8_hu_c5b73f0f131b7a72.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-8_hu_b11c5617c415750d.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;139&#34;
		data-flex-basis=&#34;334px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;A、B 两个时刻，redo log 都处于 prepare 阶段，mysql 重启后会扫描 redo log，碰到处于 prepare 阶段的 redo log，就会拿着他的事务 id 去 bin log 查是否存在此 id，若不存在，则说明 binlog 还没有刷盘，回滚事务，若存在，则说明 binlog 已经刷盘，提交事务。如此便可保证两个日志的一致性。&lt;/p&gt;
&lt;h2 id=&#34;事务没提交的时候redo-log-会被持久化到磁盘吗&#34;&gt;&lt;a href=&#34;#%e4%ba%8b%e5%8a%a1%e6%b2%a1%e6%8f%90%e4%ba%a4%e7%9a%84%e6%97%b6%e5%80%99redo-log-%e4%bc%9a%e8%a2%ab%e6%8c%81%e4%b9%85%e5%8c%96%e5%88%b0%e7%a3%81%e7%9b%98%e5%90%97&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;事务没提交的时候，redo log 会被持久化到磁盘吗？
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-9.png&#34;
	width=&#34;1306&#34;
	height=&#34;731&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-9_hu_ccb8ccb14665f8be.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-9_hu_de7b52421e169b43.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;178&#34;
		data-flex-basis=&#34;428px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;&lt;a href=&#34;#%e6%80%bb%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;总结
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL InnoDB 引擎使用 &lt;strong&gt;redo log(重做日志)&lt;/strong&gt; 保证事务的&lt;strong&gt;持久性&lt;/strong&gt;，使用 &lt;strong&gt;undo log(回滚日志)&lt;/strong&gt; 来保证事务的&lt;strong&gt;原子性&lt;/strong&gt;，这两个都是存储引擎层面的。&lt;/p&gt;
&lt;p&gt;MySQL 数据库的&lt;strong&gt;数据备份、主备、主主、主从&lt;/strong&gt;都离不开 binlog，需要依靠 binlog 来同步数据，保证数据一致性，是 Server 层面的，所有存储引擎都可以使用。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>MySQL四种事务隔离机制</title>
        <link>/zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Fri, 27 Dec 2024 12:00:00 +0000</pubDate>
        
        <guid>/zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;何为事务？&lt;/strong&gt; 一言蔽之，&lt;strong&gt;事务是逻辑上的一组操作，要么都执行，要么都不执行。&lt;/strong&gt; &amp;gt; &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原子性&lt;/strong&gt; （&lt;code&gt;Atomicity&lt;/code&gt;）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt; （&lt;code&gt;Consistency&lt;/code&gt;）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性&lt;/strong&gt; （&lt;code&gt;Isolation&lt;/code&gt;）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久性&lt;/strong&gt; （&lt;code&gt;Durability&lt;/code&gt;）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/opencourse/intro/100064201&#34;  title=&#34;周志明的软件架构课_软件架构_分布式系统_基础设施_架构演进_单体架构_SOA架构_微服务_云原生-极客时间&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;周志明的软件架构课&lt;em&gt;软件架构&lt;/em&gt;分布式系统&lt;em&gt;基础设施&lt;/em&gt;架构演进&lt;em&gt;单体架构_SOA 架构&lt;/em&gt;微服务_云原生-极客时间&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/image.png&#34;
	width=&#34;768&#34;
	height=&#34;802&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/image_hu_d5e27402bc12d27a.png 480w, /zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/image_hu_1d47680f91659ae3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;229px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;并发事务的问题&#34;&gt;&lt;a href=&#34;#%e5%b9%b6%e5%8f%91%e4%ba%8b%e5%8a%a1%e7%9a%84%e9%97%ae%e9%a2%98&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;并发事务的问题
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;丢失修改：&lt;/strong&gt; 在事务 1 读取一个数据时，另外事务 2 也访问了该数据，那么在事务 1 中修改了这个数据后，事务 2 也修改了这个数据。这样事务 1 的修改结果就被丢失，因此称为丢失修改。
&lt;ul&gt;
&lt;li&gt;**例：**事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20。事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;脏读：&lt;/strong&gt; 事务 2 读取了事务 1 未提交的数据
&lt;ul&gt;
&lt;li&gt;**例：**事务 1 读取某表中的数据 A=20 并修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并未提交到数据库， A 的值还是 20&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可重复读：&lt;/strong&gt; 事务 1 多次读同一数据。在事务 1 还没有结束时，事务 2 也访问该数据。那么，在事务 1 中的两次读数据之间，由于事务 2 的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
&lt;ul&gt;
&lt;li&gt;**例：**事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;幻读：&lt;/strong&gt; 幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
&lt;ul&gt;
&lt;li&gt;**例：**事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;并发事务控制方式&#34;&gt;&lt;a href=&#34;#%e5%b9%b6%e5%8f%91%e4%ba%8b%e5%8a%a1%e6%8e%a7%e5%88%b6%e6%96%b9%e5%bc%8f&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;并发事务控制方式
&lt;/h2&gt;&lt;p&gt;MySQL 中并发事务的控制方式无非就两种：&lt;strong&gt;锁&lt;/strong&gt; 和 &lt;strong&gt;MVCC&lt;/strong&gt;。锁可以看作是悲观控制的模式，多版本并发控制可以看作是乐观控制的模式。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html&#34;  title=&#34;InnoDB存储引擎对MVCC的实现 | JavaGuide&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;InnoDB 存储引擎对 MVCC 的实现 | JavaGuide&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;锁&lt;/strong&gt; 控制方式下会通过锁来显式控制共享资源而不是通过调度手段，MySQL 中主要是通过 &lt;strong&gt;读写锁&lt;/strong&gt; 来实现并发控制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;共享锁（S 锁）&lt;/strong&gt;：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排他锁（X 锁）&lt;/strong&gt;：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。
&lt;strong&gt;MVCC&lt;/strong&gt; 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MVCC 在 MySQL 中实现所依赖的手段主要是: &lt;strong&gt;隐藏字段、read view、undo log&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;四个事务隔离级别&#34;&gt;&lt;a href=&#34;#%e5%9b%9b%e4%b8%aa%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;四个事务隔离级别
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2014/08/20/innodb-lock.html&#34;  title=&#34;Innodb中的事务隔离级别和锁的关系 - 美团技术团队&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Innodb 中的事务隔离级别和锁的关系 - 美团技术团队&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;读已提交和 可重复读 隔离级别是基于 MVCC 实现的，可串行化 隔离级别是通过锁来实现的。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;读未提交-read-uncommitted&#34;&gt;&lt;a href=&#34;#%e8%af%bb%e6%9c%aa%e6%8f%90%e4%ba%a4-read-uncommitted&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;读未提交 (Read Uncommitted)
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;特点：在该隔离级别下，一个事务可以读取另一个事务尚未提交的数据。这就会导致脏读，即一个事务读取到的可能是另一个事务未提交的修改，这些修改可能会被回滚。&lt;/li&gt;
&lt;li&gt;问题：事务 B 读取到事务 A 修改的值，但事务 A 回滚后，数据实际上没有变化。发生了&lt;strong&gt;脏读。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;读已提交-read-committed&#34;&gt;&lt;a href=&#34;#%e8%af%bb%e5%b7%b2%e6%8f%90%e4%ba%a4-read-committed&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;读已提交 (Read Committed)
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特点：在该隔离级别下，一个事务只能读取到已提交事务的数据，因此脏读不会发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题：事务 A 在读取两次同一数据时，第二次读取的数据可能会&lt;strong&gt;因其他事务的提交而发生变化&lt;/strong&gt; ，这就是&lt;strong&gt;不可重复读&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;「读已提交」事务期间的多次读取同一条数据，&lt;strong&gt;前后两次读的数据可能会出现不一致&lt;/strong&gt; ，因为可能这期间另外一个事务修改了该记录，并提交了事务。&lt;strong&gt;这就是不可重复读的问题&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;可重复读-repeatable-read&#34;&gt;&lt;a href=&#34;#%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb-repeatable-read&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;可重复读 (Repeatable Read)
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;特点：在该隔离级别下，事务会看到在事务开始时一致的&lt;strong&gt;数据快照&lt;/strong&gt;，不可重复读的问题被解决。&lt;/li&gt;
&lt;li&gt;问题：如果事务 A 查询范围的数据（例如某一时间段内的所有交易记录），事务 B&lt;strong&gt;插入&lt;/strong&gt; 的新数据可能会被事务 A 在第二次查询中看到，导致事务 A 两次查询到的数据量不一致，这就是&lt;strong&gt;幻读，可重复读仅解决部分幻读&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;用 Read View 只能保证&amp;quot;快照读&amp;quot;不幻读；一旦事务里出现&amp;quot;当前读&amp;quot;（UPDATE/DELETE/SELECT &amp;hellip; FOR UPDATE 等），就会重新加 Next-Key Lock，这时若别的事务新插入的记录落在这个锁范围里，就可能被本事务再次看到，于是出现&amp;quot;部分幻读&amp;quot;。
「可重复读」隔离级别是&lt;strong&gt;启动事务时生成一个 Read View，然后整个事务期间都在用
这个 Read View&lt;/strong&gt; ，这样就保证了在事务期间读到的数据都是事务启动前的记录。&lt;strong&gt;解决了不可重复读和部分幻读。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;串行化-serializable&#34;&gt;&lt;a href=&#34;#%e4%b8%b2%e8%a1%8c%e5%8c%96-serializable&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;串行化 (Serializable)
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;特点：在该隔离级别下，&lt;strong&gt;事务是完全隔离、串行执行&lt;/strong&gt;。其他事务必须等当前事务完成才能开始执行，这避免了所有并发问题（脏读、不可重复读和幻读），但也大大降低了性能。
&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/image-1.png&#34;
	width=&#34;1080&#34;
	height=&#34;464&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/image-1_hu_f56d88340cfa1784.png 480w, /zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/image-1_hu_fdbd2950bc1baf4f.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;232&#34;
		data-flex-basis=&#34;558px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;幻读&#34;&gt;&lt;a href=&#34;#%e5%b9%bb%e8%af%bb&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;幻读
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;幻读 VS 不可重复读&lt;/strong&gt;&lt;br&gt;
幻读重点在于&lt;strong&gt;数据是否存在&lt;/strong&gt;。原本不存在的数据却真实的存在了，这便是幻读。引起幻读的原因在于另一个事务进行了 INSERT 操作。&lt;/li&gt;
&lt;li&gt;不可重复读重点在于&lt;strong&gt;数据值是否被改变&lt;/strong&gt;。在一个事务中对同一条记录进行查询，第一次读取到的数据和第二次读取到的数据不一致，这便是可重复读。引起不可重复读的原因在于另一个事务进行了 UPDATE 或者是 DELETE 操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说：幻读是说数据的条数发生了变化，原本不存在的数据存在了。不可重复读是说数据的内容发生了变化，原本存在的数据的内容发生了改变。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可重复读隔离下为什么会产生幻读&lt;/strong&gt;&lt;br&gt;
在可重复读隔离级别下，普通的查询是&lt;strong&gt;快照读&lt;/strong&gt; ，是不会看到别的事务插入的数据的，&lt;strong&gt;就没有幻读&lt;/strong&gt; 。因此，幻读在 &lt;strong&gt;当前读（&lt;/strong&gt; select &amp;hellip; for update 等语句，使用临键锁**）** 下才会出现。&lt;br&gt;
MySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete,这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MySQL 中如何实现可重复读&lt;/strong&gt;&lt;br&gt;
当隔离级别为可重复读的时候，事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View。也就是说：不管其他事务怎么修改数据，，对于 A 事务而言，它能看到的数据永远都是第一次 SELECT 时看到的数据。这显然不合理，如果其它事务插入了数据，A 事务却只能看到过去的数据，读取不了当前的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解决幻读的办法&lt;/strong&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/mysql/transaction/phantom.html&#34;  title=&#34;MySQL 可重复读隔离级别，完全解决幻读了吗？ | 小林coding&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL 可重复读隔离级别，完全解决幻读了吗？ | 小林 coding&lt;/a&gt;{#解决幻读的方法}&lt;/p&gt;
&lt;p&gt;**解决幻读的核心思想就是事务 A 在操作某张表数据的时候，另外事务 B 不允许新增或者删除这张表中的数据。**解决幻读的方式主要有以下几种：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将事务隔离级别调整为 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在可重复读的事务级别下，给事务操作的这张表添加表锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在可重复读的事务级别下，给事务操作的这张表添加 临键锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;其他情况下的幻读&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成一个数据快照，之后事务 B 向表中新插入了一条 id=5 的记录并提交（此时是当前读）。接着，事务 A 对 id=5 这条记录进行了更新操作（看不见但是能更新），在这个时刻这条新记录的 trx id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 A 先快照读，得到数据量为 3，然后事务 B 插入一条数据并提交事务，事务 A 使用当前读得到的数量就是 4 了，前后数据量不对。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>MySQL入门概述</title>
        <link>/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/</link>
        <pubDate>Thu, 26 Dec 2024 14:43:23 +0000</pubDate>
        
        <guid>/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;MySQL 是建立在关系模型基础上的关系型数据库，关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;字段类型&#34;&gt;&lt;a href=&#34;#%e5%ad%97%e6%ae%b5%e7%b1%bb%e5%9e%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;字段类型
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image.png&#34;
	width=&#34;1654&#34;
	height=&#34;1426&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image_hu_8d67505423ab9cf5.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image_hu_fe9bc902be500416.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;115&#34;
		data-flex-basis=&#34;278px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;TINYINT 占 1 字节，INT 占 4 字节，BIGINT 占 8 字节。&lt;/li&gt;
&lt;li&gt;CHAR 是定长字符串，VARCHAR 是变长字符串。CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR 在存储时需要使用 1 或 2 个额外&lt;strong&gt;字节&lt;/strong&gt; 记录字符串的长度，检索时不需要处理。&lt;strong&gt;CHAR（100）指的是 100 个字符而非字节&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MySQL 中字符的存储是与字符集（&lt;code&gt;CHARSET&lt;/code&gt;）相关的，具体的字节数取决于你使用的字符集和编码。 &lt;strong&gt;&lt;code&gt;latin1&lt;/code&gt;&lt;/strong&gt; 编码（单字节编码），每个字符占用 &lt;strong&gt;1 字节&lt;/strong&gt; 。&lt;strong&gt;&lt;code&gt;utf8mb4&lt;/code&gt;&lt;/strong&gt; 编码（变长编码），每个字符可能占用 &lt;strong&gt;1 到 4 字节&lt;/strong&gt;，具体取决于字符的内容。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;varchar100和-varchar10区别&#34;&gt;&lt;a href=&#34;#varchar100%e5%92%8c-varchar10%e5%8c%ba%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;VARCHAR(100)和 VARCHAR(10)区别
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;VARCHAR(100)和 VARCHAR(10)都是变长类型，表示能存储最多 100 个字符和 10 个字符。但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，其所占用的磁盘空间是基于&lt;strong&gt;实际存储的字符长度&lt;/strong&gt;，而不是字段的最大长度。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;decimal-和-floatdouble-区别&#34;&gt;&lt;a href=&#34;#decimal-%e5%92%8c-floatdouble-%e5%8c%ba%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;DECIMAL 和 FLOAT/DOUBLE 区别
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;DECIMAL 是定点数，可以存储精确的小数值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FLOAT（4 字节），DOUBLE（8 字节） 是浮点数，只能存储近似的小数值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;text-和-blob&#34;&gt;&lt;a href=&#34;#text-%e5%92%8c-blob&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;TEXT 和 BLOB
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;TEXT 可以存储更长的字符串，即长文本数据，例如博客内容。&lt;/li&gt;
&lt;li&gt;BLOB 类型主要用于存储二进制大对象，例如图片、音视频等文件。&lt;/li&gt;
&lt;li&gt;TEXT 和 BLOB 缺点：
&lt;ul&gt;
&lt;li&gt;不能有默认值。&lt;/li&gt;
&lt;li&gt;检索效率较低。&lt;/li&gt;
&lt;li&gt;在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表。&lt;/li&gt;
&lt;li&gt;不能直接创建索引，需要指定前缀长度。
&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-1.png&#34;
	width=&#34;990&#34;
	height=&#34;449&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-1_hu_dada62f7d2c52a32.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-1_hu_423eb2c7607370a0.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;220&#34;
		data-flex-basis=&#34;529px&#34;
	
&gt; &amp;gt; &lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-2.png&#34;
	width=&#34;999&#34;
	height=&#34;457&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-2_hu_8d460f34bb7ae061.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-2_hu_5cff2a90b8be2234.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;218&#34;
		data-flex-basis=&#34;524px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;datetime-和-timestamp&#34;&gt;&lt;a href=&#34;#datetime-%e5%92%8c-timestamp&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;DATETIME 和 TIMESTAMP
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html#%E6%97%B6%E5%8C%BA%E4%BF%A1%E6%81%AF&#34;  title=&#34;MySQL日期类型选择建议 | JavaGuide&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL 日期类型选择建议 | JavaGuide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。
&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-3.png&#34;
	width=&#34;1594&#34;
	height=&#34;614&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-3_hu_38c6b5a7aa80305.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-3_hu_618882815bdb491b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;259&#34;
		data-flex-basis=&#34;623px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;null-和的区别&#34;&gt;&lt;a href=&#34;#null-%e5%92%8c%e7%9a%84%e5%8c%ba%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;NULL 和&amp;quot;&amp;ldquo;的区别
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NULL&lt;/code&gt; 代表一个不确定的值,就算是两个 &lt;code&gt;NULL&lt;/code&gt;,它俩也不一定相等。例如，&lt;code&gt;SELECT NULL=NULL&lt;/code&gt;的结果为 NULL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;&#39;&lt;/code&gt;的长度是 0，是不占用空间的，而&lt;code&gt;NULL&lt;/code&gt; 是需要占用空间&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;为什么-mysql-不建议使用-null-作为列默认值&#34;&gt;&lt;a href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88-mysql-%e4%b8%8d%e5%bb%ba%e8%ae%ae%e4%bd%bf%e7%94%a8-null-%e4%bd%9c%e4%b8%ba%e5%88%97%e9%bb%98%e8%ae%a4%e5%80%bc&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;为什么 MySQL 不建议使用 &lt;code&gt;NULL&lt;/code&gt; 作为列默认值?
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt; 会影响聚合函数的结果。例如，&lt;code&gt;SUM&lt;/code&gt;、&lt;code&gt;AVG&lt;/code&gt;、&lt;code&gt;MIN&lt;/code&gt;、&lt;code&gt;MAX&lt;/code&gt; 等聚合函数会忽略 &lt;code&gt;NULL&lt;/code&gt; 值，如果参数是某个字段名(&lt;code&gt;COUNT(列名)&lt;/code&gt;)，则会忽略 &lt;code&gt;NULL&lt;/code&gt; 值，只统计非空值的个数。查询 &lt;code&gt;NULL&lt;/code&gt; 值时，必须使用 &lt;code&gt;IS NULL&lt;/code&gt; 或 &lt;code&gt;IS NOT NULLl&lt;/code&gt; 来判断，而不能使用 =、!=、 &amp;lt;、&amp;gt; 之类的比较运算符。而&lt;code&gt;&#39;&#39;&lt;/code&gt;是可以使用这些比较运算符的。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;boolean-类型如何表示&#34;&gt;&lt;a href=&#34;#boolean-%e7%b1%bb%e5%9e%8b%e5%a6%82%e4%bd%95%e8%a1%a8%e7%a4%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Boolean 类型如何表示
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;mysql-基础架构&#34;&gt;&lt;a href=&#34;#mysql-%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;MySQL 基础架构
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-4.png&#34;
	width=&#34;1437&#34;
	height=&#34;1088&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-4_hu_703d27ddae52e213.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-4_hu_a495e2d79e84f504.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;132&#34;
		data-flex-basis=&#34;316px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连接器：&lt;/strong&gt; 身份认证和权限相关(登录 MySQL 的时候)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查询缓存：&lt;/strong&gt; 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分析器：&lt;/strong&gt; 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化器：&lt;/strong&gt; 按照 MySQL 认为最优的方案去执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行器：&lt;/strong&gt; 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插件式存储引擎&lt;/strong&gt; ：主要负责数据的存储和读取，采用的是&lt;strong&gt;插件式架构&lt;/strong&gt;，支持 InnoDB、MyISAM、Memory 等多种存储引擎。InnoDB 是 MySQL 的默认存储引擎，绝大部分场景使用 InnoDB 就是最好的选择。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;mysql-存储引擎&#34;&gt;&lt;a href=&#34;#mysql-%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;MySQL 存储引擎
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html&#34;  title=&#34;MySQL :: MySQL 8.0 Reference Manual :: 17 The InnoDB Storage Engine&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL :: MySQL 8.0 Reference Manual :: 17 The InnoDB Storage Engine&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html&#34;  title=&#34;MySQL :: MySQL 8.0 Reference Manual :: 18 Alternative Storage Engines&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL :: MySQL 8.0 Reference Manual :: 18 Alternative Storage Engines&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-5.png&#34;
	width=&#34;2152&#34;
	height=&#34;538&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-5_hu_2c6352c126711b07.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-5_hu_58ed7189f3e90260.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;400&#34;
		data-flex-basis=&#34;960px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。 在上述所有引擎中，&lt;strong&gt;只有 InnoDB 引擎支持事务。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;上面还提到过 MySQL 存储引擎采用的是 &lt;strong&gt;插件式架构&lt;/strong&gt; ，支持多种存储引擎。&lt;strong&gt;存储引擎是基于表的，而不是数据库。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;myisam-和-innodb-区别&#34;&gt;&lt;a href=&#34;#myisam-%e5%92%8c-innodb-%e5%8c%ba%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;MyISAM 和 InnoDB 区别
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;锁：&lt;/strong&gt; MyISAM 只有表级锁，而 InnoDB 支持行级锁和表级锁，默认为行级锁。对于并发操作，细粒度的行级锁性能肯定更好！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事务：&lt;/strong&gt;
MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了四个隔离级别，分别是：&lt;strong&gt;读未提交、读已提交、可重复读、可串行化&lt;/strong&gt;。InnoDB 默认是可重读，隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;外键：&lt;/strong&gt; MyISAM 不支持物理外键，而 InnoDB 支持物理外键。然而外键的维护对数据库性能也有一定影响，特别是分布式、高并发项目，一个字段的更新往往会引起其他字段的更新，极大拉低数据库性能，因此是不建议使用物理外键，而是逻辑外键（在代码中进行约束）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据恢复&lt;/strong&gt; ：MyISAM 不支持，而 InnoDB 支持。使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候依赖&lt;strong&gt;redo.log&lt;/strong&gt;使数据库恢复到崩溃前的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MVCC：&lt;/strong&gt; MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。MyISAM 显然是不支持 MVCC 的，毕竟连行级锁都没有。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;索引：&lt;/strong&gt; 都使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据缓存策略和机制：&lt;/strong&gt; InnoDB 使用缓冲池（Buffer Pool）缓存数据页和索引页，MyISAM 使用键缓存（Key Cache）仅缓存索引页而不缓存数据页。当数据库对数据做修改的时候，需要把数据页从磁盘读到 buffer pool 中，&lt;strong&gt;然后在 buffer pool 中进行修改&lt;/strong&gt; ，此时 buffer pool 中的数据页就与磁盘上的数据页&lt;strong&gt;内容不一致&lt;/strong&gt;，如果这个时候发生 DB 服务重启，那么这些数据并没有同步到磁盘文件中（同步到磁盘文件是个随机 IO），就会发生数据丢失，如果这个时候，能够在有一个文件，当 buffer pool 中的数据页变更结束后，把相应修改记录记录到这个文件（记录日志是顺序 IO），那么当 DB 服务进行恢复 DB 的时候，可以根据这个文件的记录内容，重新持久化刷新到磁盘文件，保持数据的一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能：&lt;/strong&gt; InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的&lt;strong&gt;读写能力呈线性增长&lt;/strong&gt;。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-6.png&#34;
	width=&#34;1606&#34;
	height=&#34;549&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-6_hu_66e9c13c13f7c56c.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-6_hu_41924396b50195ff.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;292&#34;
		data-flex-basis=&#34;702px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;mysql-如何存储-ip-地址&#34;&gt;&lt;a href=&#34;#mysql-%e5%a6%82%e4%bd%95%e5%ad%98%e5%82%a8-ip-%e5%9c%b0%e5%9d%80&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;MySQL 如何存储 IP 地址
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;可以使用字符串存储，但是存储空间相对较大（每个字符占用 1 字节），每个 IP 占用空间为 7-15 个字节（1.1.1.1 占用 7 字节，100.100.100.100 占用 15 字节）。&lt;/p&gt;
&lt;p&gt;对于 ipv4，其实是 4 字节 32 位的数字，可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。&lt;/p&gt;
&lt;p&gt;MySQL 提供了两个方法来处理 ip 地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;INET_ATON()&lt;/code&gt;：把 ip 转为无符号整型 (4-8 位)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INET_NTOA()&lt;/code&gt; :把整型的 ip 转为地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;插入数据前，先用 &lt;code&gt;INET_ATON()&lt;/code&gt; 把 ip 地址转为整型，显示数据时，使用 &lt;code&gt;INET_NTOA()&lt;/code&gt; 把整型的 ip 地址转为地址显示即可。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
