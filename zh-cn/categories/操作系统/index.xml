<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>操作系统 on 青秋博客</title>
        <link>/zh-cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
        <description>Recent content in 操作系统 on 青秋博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>青秋博客</copyright>
        <lastBuildDate>Fri, 05 Sep 2025 19:39:19 +0000</lastBuildDate><atom:link href="/zh-cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>线程生命周期、守护线程、礼让线程、插入线程</title>
        <link>/zh-cn/post/2025/09/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8F%92%E5%85%A5%E7%BA%BF%E7%A8%8B/</link>
        <pubDate>Fri, 05 Sep 2025 19:39:19 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/09/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8F%92%E5%85%A5%E7%BA%BF%E7%A8%8B/</guid>
        <description>&lt;h2 id=&#34;线程生命周期&#34;&gt;&lt;a href=&#34;#%e7%ba%bf%e7%a8%8b%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;线程生命周期
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;enum&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;State&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * Thread state for a thread which has not yet started.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         */&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NEW&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * Thread state for a runnable thread.  A thread in the runnable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * state is executing in the Java virtual machine but it may
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * be waiting for other resources from the operating system
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * such as processor.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         */&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * Thread state for a thread blocked waiting for a monitor lock.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * A thread in the blocked state is waiting for a monitor lock
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * to enter a synchronized block/method or
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * reenter a synchronized block/method after calling
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * {@link Object#wait() Object.wait}.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         */&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BLOCKED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * Thread state for a waiting thread.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * A thread is in the waiting state due to calling one of the
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * following methods:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * &amp;lt;ul&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         *   &amp;lt;li&amp;gt;{@link Object#wait() Object.wait} with no timeout&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         *   &amp;lt;li&amp;gt;{@link #join() Thread.join} with no timeout&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         *   &amp;lt;li&amp;gt;{@link LockSupport#park() LockSupport.park}&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * &amp;lt;/ul&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * &amp;lt;p&amp;gt;A thread in the waiting state is waiting for another thread to
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * perform a particular action.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * For example, a thread that has called &amp;lt;tt&amp;gt;Object.wait()&amp;lt;/tt&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * on an object is waiting for another thread to call
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * &amp;lt;tt&amp;gt;Object.notify()&amp;lt;/tt&amp;gt; or &amp;lt;tt&amp;gt;Object.notifyAll()&amp;lt;/tt&amp;gt; on
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * that object. A thread that has called &amp;lt;tt&amp;gt;Thread.join()&amp;lt;/tt&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * is waiting for a specified thread to terminate.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         */&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WAITING&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * Thread state for a waiting thread with a specified waiting time.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * A thread is in the timed waiting state due to calling one of
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * the following methods with a specified positive waiting time:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * &amp;lt;ul&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         *   &amp;lt;li&amp;gt;{@link #sleep Thread.sleep}&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         *   &amp;lt;li&amp;gt;{@link Object#wait(long) Object.wait} with timeout&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         *   &amp;lt;li&amp;gt;{@link #join(long) Thread.join} with timeout&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         *   &amp;lt;li&amp;gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         *   &amp;lt;li&amp;gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&amp;lt;/li&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * &amp;lt;/ul&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         */&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TIMED_WAITING&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * Thread state for a terminated thread.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         * The thread has completed execution.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;         */&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TERMINATED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/09/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8F%92%E5%85%A5%E7%BA%BF%E7%A8%8B/image.png&#34;
	width=&#34;1539&#34;
	height=&#34;611&#34;
	srcset=&#34;/zh-cn/post/2025/09/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8F%92%E5%85%A5%E7%BA%BF%E7%A8%8B/image_hu_a728841c78ac2d4b.png 480w, /zh-cn/post/2025/09/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8F%92%E5%85%A5%E7%BA%BF%E7%A8%8B/image_hu_69dc608785f321a9.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;251&#34;
		data-flex-basis=&#34;604px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;在 Thread 类中，有如下常用的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/09/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8F%92%E5%85%A5%E7%BA%BF%E7%A8%8B/image-1.png&#34;
	width=&#34;1216&#34;
	height=&#34;603&#34;
	srcset=&#34;/zh-cn/post/2025/09/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8F%92%E5%85%A5%E7%BA%BF%E7%A8%8B/image-1_hu_f7f03b583a7885d.png 480w, /zh-cn/post/2025/09/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8F%92%E5%85%A5%E7%BA%BF%E7%A8%8B/image-1_hu_c7c33b58a17c04d4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;201&#34;
		data-flex-basis=&#34;483px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;线程优先级&#34;&gt;&lt;a href=&#34;#%e7%ba%bf%e7%a8%8b%e4%bc%98%e5%85%88%e7%ba%a7&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;线程优先级
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;线程调度方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抢占式调度：多个线程抢夺 CPU 的执行权，CPU 在什么时候执行哪条线程是不确定的，执行多长时间也是不确定的，所以抢占式调度它体现了一个随机性。&lt;/li&gt;
&lt;li&gt;非抢占式调度 / 分时调度模型：所有线程轮流使用 CPU 的使用权，&lt;strong&gt;平均分配&lt;/strong&gt;每个线程占用 CPU 的时间片 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在 Java 当中，它采取了第一种抢占式调度模型的方式。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;在 Thread 类中，最小优先级是 1，最大是 10，默认为 5，优先级越高，该线程抢到 cpu 执行权的机会越大（注意是机会很大，不是 100%）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/09/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8F%92%E5%85%A5%E7%BA%BF%E7%A8%8B/image-2.png&#34;
	width=&#34;718&#34;
	height=&#34;498&#34;
	srcset=&#34;/zh-cn/post/2025/09/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8F%92%E5%85%A5%E7%BA%BF%E7%A8%8B/image-2_hu_3d9a5da4f16094c5.png 480w, /zh-cn/post/2025/09/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8F%92%E5%85%A5%E7%BA%BF%E7%A8%8B/image-2_hu_a9efa895176b331f.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;144&#34;
		data-flex-basis=&#34;346px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;守护线程&#34;&gt;&lt;a href=&#34;#%e5%ae%88%e6%8a%a4%e7%ba%bf%e7%a8%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;守护线程
&lt;/h2&gt;&lt;p&gt;守护线程又叫备胎线程，通过 setDaemon()方法把当前线程设置为守护线程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当仅剩的线程是非守护线程时，该线程会继续执行，当仅剩的线程是守护线程时，Java 虚拟机将直接退出&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意：setDaemon(true)方法必须在 start()方法前执行，否则会抛出 ILLegalThreadStateException 异常。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在守护线程中产生的新线程也是守护线程。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;应用场景：在 QQ 聊天界面传输文件，如果在文件未传输完的情况下退出界面，那么文件就会传输中止&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;礼让线程&#34;&gt;&lt;a href=&#34;#%e7%a4%bc%e8%ae%a9%e7%ba%bf%e7%a8%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;礼让线程
&lt;/h2&gt;&lt;p&gt;通过 yield()方法，当前线程将让出当前线程的执行权&lt;/p&gt;
&lt;h2 id=&#34;插入线程&#34;&gt;&lt;a href=&#34;#%e6%8f%92%e5%85%a5%e7%ba%bf%e7%a8%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;插入线程
&lt;/h2&gt;&lt;p&gt;通过 join()方法，可以在线程 A 执行的时候，让线程 B 插队，等线程 B 执行完再执行线程 A，或者调用 join 方法时传入毫秒时间，让线程 B 插队的时间受控&lt;/p&gt;
</description>
        </item>
        <item>
        <title>IO多路复用select、poll、epoll</title>
        <link>/zh-cn/post/2025/09/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8selectpollepoll/</link>
        <pubDate>Fri, 05 Sep 2025 12:39:19 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/09/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8selectpollepoll/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#select-poll&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考此文章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;最基本的-socket-模型&#34;&gt;&lt;a href=&#34;#%e6%9c%80%e5%9f%ba%e6%9c%ac%e7%9a%84-socket-%e6%a8%a1%e5%9e%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;最基本的 socket 模型
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;socket 模型可以使两个进程跨主机通信，创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP。&lt;/p&gt;
&lt;p&gt;以 TCP 的 socket 为例：&lt;/p&gt;
&lt;p&gt;服务端首先调用 socket 函数创建网络协议及传输协议，然后调用 bind 函数，为 socket 绑定 ip 地址和端口，最后调用 listen 函数监听并通过 accept 函数从内核获取客户端连接。&lt;/p&gt;
&lt;p&gt;客户端创建 socket，调用 connect 函数，指定 ip 地址和端口，TCP 三次握手后就可以和服务端通信了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/09/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8selectpollepoll/image.png&#34;
	width=&#34;407&#34;
	height=&#34;722&#34;
	srcset=&#34;/zh-cn/post/2025/09/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8selectpollepoll/image_hu_b539cac5f6ed9631.png 480w, /zh-cn/post/2025/09/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8selectpollepoll/image_hu_c3f08127940f3b21.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;56&#34;
		data-flex-basis=&#34;135px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP 连接过程中，服务器的内核实际上为每个 Socket 维护了两个队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「还没完全建立」连接的队列，称为 TCP 半连接队列，这个队列都是没有完成三次握手的连接，此时服务端处于 syn_rcvd 的状态；&lt;/li&gt;
&lt;li&gt;「已经建立」连接的队列，称为 TCP 全连接队列，这个队列都是完成了三次握手的连接，此时服务端处于 established 状态；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>top命令和ps命令</title>
        <link>/zh-cn/post/2025/09/top%E5%91%BD%E4%BB%A4%E5%92%8Cps%E5%91%BD%E4%BB%A4/</link>
        <pubDate>Fri, 05 Sep 2025 12:39:19 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/09/top%E5%91%BD%E4%BB%A4%E5%92%8Cps%E5%91%BD%E4%BB%A4/</guid>
        <description>&lt;h2 id=&#34;top&#34;&gt;&lt;a href=&#34;#top&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;top
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;主要显示的是&lt;strong&gt;进程&lt;/strong&gt;信息。&lt;/li&gt;
&lt;li&gt;默认情况下，&lt;code&gt;top&lt;/code&gt; 显示的是系统中当前活动的进程，并且会&lt;strong&gt;实时更新&lt;/strong&gt;（默认每 3 秒刷新一次）。&lt;/li&gt;
&lt;li&gt;它显示的是进程的资源占用情况，如 CPU 使用率、内存使用率、进程 ID（PID）、进程优先级等。&lt;/li&gt;
&lt;li&gt;如果需要查看线程，可以通过特定选项如 &lt;strong&gt;&lt;code&gt;-H切换到线程模式，&lt;/code&gt;来显示线程信息&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;ps&#34;&gt;&lt;a href=&#34;#ps&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;ps
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;主要显示的是&lt;strong&gt;进程&lt;/strong&gt;信息。&lt;/li&gt;
&lt;li&gt;默认情况下，&lt;code&gt;ps&lt;/code&gt; 显示的是当前终端会话中的进程信息，&lt;strong&gt;静态显示&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;可以通过不同的选项（如 &lt;code&gt;-e&lt;/code&gt;、&lt;code&gt;-a&lt;/code&gt;、&lt;code&gt;-x&lt;/code&gt; 等）来显示系统中所有进程或特定用户的所有进程。&lt;/li&gt;
&lt;li&gt;如果需要查看线程，可以通过 &lt;strong&gt;&lt;code&gt;-L&lt;/code&gt; 选项来显示线程信息&lt;/strong&gt;。每个线程也会被显示为一行，但可以通过 &lt;code&gt;ps -L -p &amp;lt;PID&amp;gt;&lt;/code&gt; 来查看特定进程的所有线程。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;如何定位到进程的某个线程&#34;&gt;&lt;a href=&#34;#%e5%a6%82%e4%bd%95%e5%ae%9a%e4%bd%8d%e5%88%b0%e8%bf%9b%e7%a8%8b%e7%9a%84%e6%9f%90%e4%b8%aa%e7%ba%bf%e7%a8%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;如何定位到进程的某个线程
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;找到进程 ID（PID）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ps -ef | grep &amp;lt;进程名&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显示进程的所有线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ps -L&lt;/code&gt; 选项可以显示指定进程的所有线程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/09/top%E5%91%BD%E4%BB%A4%E5%92%8Cps%E5%91%BD%E4%BB%A4/image.png&#34;
	width=&#34;1446&#34;
	height=&#34;931&#34;
	srcset=&#34;/zh-cn/post/2025/09/top%E5%91%BD%E4%BB%A4%E5%92%8Cps%E5%91%BD%E4%BB%A4/image_hu_1e797ac9c2d04920.png 480w, /zh-cn/post/2025/09/top%E5%91%BD%E4%BB%A4%E5%92%8Cps%E5%91%BD%E4%BB%A4/image_hu_d960372203ebcfe2.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;155&#34;
		data-flex-basis=&#34;372px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;kill--9-和-2&#34;&gt;&lt;a href=&#34;#kill--9-%e5%92%8c-2&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;kill -9 和-2
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;-9  强制终止进程的信号，它会立即终止目标进程，不会给进程任何清理资源的机会。&lt;/p&gt;
&lt;p&gt;-2  中断信号，通常用于通知进程用户请求的中断。这个信号可以被进程捕获、阻塞或忽略。如果进程没有处理这个信号，它会默认终止进程。通常用于正常终止进程，给进程一个机会来清理资源、保存状态等。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>进程间通信的几种方式</title>
        <link>/zh-cn/post/2025/09/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
        <pubDate>Thu, 04 Sep 2025 13:39:19 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/09/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
        <description>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;管道&lt;/strong&gt;：分匿名和命名。匿名管道（如  &lt;code&gt;|&lt;/code&gt;）只用于父子进程，单向通信，数据存内核；命名管道有文件系统标识，可跨无亲缘关系进程，均按先进先出传无格式流。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息队列&lt;/strong&gt;：内核中的消息链表，数据是带类型的消息体（需收发方匹配类型），解决管道无格式问题，但需用户态与内核态数据拷贝，速度不及时。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享内存&lt;/strong&gt;：内核分配共享空间，进程直接访问，无需拷贝，是最快的方式，但多进程访问需同步，否则数据易错乱。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信号量&lt;/strong&gt;：本质是资源计数器，通过 P/V 原子操作控制，用于保护共享资源（互斥）或同步进程，解决共享内存的竞争问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信号&lt;/strong&gt;：异步通知机制，内核通知进程系统事件（如  &lt;code&gt;Ctrl+C&lt;/code&gt;、&lt;code&gt;kill&lt;/code&gt;  命令），进程可默认处理、捕捉或忽略，仅  &lt;code&gt;SIGKILL&lt;/code&gt;  和  &lt;code&gt;SIGSTOP&lt;/code&gt;  无法捕捉 / 忽略。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;套接字 Socket&lt;/strong&gt;：可跨主机通信，也支持本地通信，分 TCP（可靠）、UDP（不可靠）、本地进程间通信三种类型，是跨主机进程通信的核心方式。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>线程崩溃了，所属进程也会崩溃吗</title>
        <link>/zh-cn/post/2025/08/%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BA%86%E6%89%80%E5%B1%9E%E8%BF%9B%E7%A8%8B%E4%B9%9F%E4%BC%9A%E5%B4%A9%E6%BA%83%E5%90%97/</link>
        <pubDate>Sat, 30 Aug 2025 15:03:04 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/08/%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BA%86%E6%89%80%E5%B1%9E%E8%BF%9B%E7%A8%8B%E4%B9%9F%E4%BC%9A%E5%B4%A9%E6%BA%83%E5%90%97/</guid>
        <description>&lt;p&gt;&lt;strong&gt;一般来说&lt;/strong&gt;，线程如果因为非法访问内存引发崩溃，那么进程也会崩溃，因为各个线程的地址空间共享，非法访问内存会影响其他线程，引发严重后果。&lt;/p&gt;
&lt;h2 id=&#34;进程如何崩溃&#34;&gt;&lt;a href=&#34;#%e8%bf%9b%e7%a8%8b%e5%a6%82%e4%bd%95%e5%b4%a9%e6%ba%83&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;进程如何崩溃
&lt;/h2&gt;&lt;p&gt;进程崩溃是通过&lt;strong&gt;信号&lt;/strong&gt;实现的，常用的 kill -9 就是直接给指定进程 pid 发送终止信号 9。&lt;/p&gt;
&lt;h2 id=&#34;cc-中线程崩溃导致进程崩溃的原因&#34;&gt;&lt;a href=&#34;#cc-%e4%b8%ad%e7%ba%bf%e7%a8%8b%e5%b4%a9%e6%ba%83%e5%af%bc%e8%87%b4%e8%bf%9b%e7%a8%8b%e5%b4%a9%e6%ba%83%e7%9a%84%e5%8e%9f%e5%9b%a0&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;C/C++ 中线程崩溃导致进程崩溃的原因
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非法内存访问&lt;/strong&gt;：如果线程因为非法访问内存（如访问未分配的内存、写入只读内存等）而崩溃，操作系统会发送 &lt;code&gt;SIGSEGV&lt;/code&gt; 信号给进程。默认情况下，操作系统会终止整个进程，因为这种错误可能会导致进程的地址空间处于不稳定状态，影响其他线程的运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信号处理机制&lt;/strong&gt;：操作系统通过信号机制处理线程的崩溃。如果进程没有定义自己的信号处理函数，操作系统会执行默认的信号处理程序，导致进程退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java-中线程崩溃不会导致-jvm-崩溃的原因&#34;&gt;&lt;a href=&#34;#java-%e4%b8%ad%e7%ba%bf%e7%a8%8b%e5%b4%a9%e6%ba%83%e4%b8%8d%e4%bc%9a%e5%af%bc%e8%87%b4-jvm-%e5%b4%a9%e6%ba%83%e7%9a%84%e5%8e%9f%e5%9b%a0&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Java 中线程崩溃不会导致 JVM 崩溃的原因
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JVM 的信号处理机制&lt;/strong&gt;：&lt;strong&gt;JVM 定义了自己的信号处理函数，拦截了 &lt;code&gt;SIGSEGV&lt;/code&gt; 等信号。当线程崩溃时，JVM 会捕获这些信号，并进行内部处理，而不是直接终止整个进程。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常处理机制&lt;/strong&gt;：在 Java 中，线程崩溃通常会抛出异常（如 &lt;code&gt;NullPointerException&lt;/code&gt; 或 &lt;code&gt;StackOverflowError&lt;/code&gt;）。JVM 会捕获这些异常并进行处理，而不是直接终止整个 JVM。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>虚拟内存和虚拟页面</title>
        <link>/zh-cn/post/2025/08/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E9%A1%B5%E9%9D%A2/</link>
        <pubDate>Fri, 29 Aug 2025 22:20:30 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/08/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E9%A1%B5%E9%9D%A2/</guid>
        <description>&lt;h2 id=&#34;虚拟内存&#34;&gt;&lt;a href=&#34;#%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;虚拟内存
&lt;/h2&gt;&lt;p&gt;虚拟内存是现代操作系统提供的一种内存管理机制，它&lt;strong&gt;允许程序访问比实际物理内存更大的地址空间&lt;/strong&gt;。虚拟内存通过将程序的地址空间划分为多个固定大小的块（称为页面），并将这些页面映射到物理内存或磁盘上的页面文件中，从而实现高效的内存管理和资源利用。&lt;/p&gt;
&lt;p&gt;正常情况下，一块内存不能同时运行多个程序，如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，因为他们都引用了**绝对物理地址，**而虚拟内存让操作系统为每个进程分配独立的一套「&lt;strong&gt;虚拟地址&lt;/strong&gt;」，这样进程所使用的地址「隔离」开来，各玩各的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/08/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E9%A1%B5%E9%9D%A2/image.png&#34;
	width=&#34;557&#34;
	height=&#34;672&#34;
	srcset=&#34;/zh-cn/post/2025/08/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E9%A1%B5%E9%9D%A2/image_hu_ae78660271288950.png 480w, /zh-cn/post/2025/08/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E9%A1%B5%E9%9D%A2/image_hu_1427f5300029098.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;82&#34;
		data-flex-basis=&#34;198px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;虚拟页&#34;&gt;&lt;a href=&#34;#%e8%99%9a%e6%8b%9f%e9%a1%b5&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;虚拟页
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;虚拟页是虚拟内存的基本单位&lt;/strong&gt;，每个虚拟页是一个固定大小的内存块。操作系统将程序的地址空间划分为多个虚拟页面，并通过页表（Page Table）将虚拟页面映射到物理内存中的物理页面或磁盘上的页面文件中。&lt;/p&gt;
&lt;h3 id=&#34;文件映射-mmapmemory-mapped-file&#34;&gt;&lt;a href=&#34;#%e6%96%87%e4%bb%b6%e6%98%a0%e5%b0%84-mmapmemory-mapped-file&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;文件映射 mmap（Memory-Mapped File）
&lt;/h3&gt;&lt;p&gt;文件映射是一种将&lt;strong&gt;文件内容直接映射到进程的地址空间&lt;/strong&gt;的技术。通过文件映射，程序可以直接通过内存地址访问文件内容，无需通过传统的 &lt;code&gt;read&lt;/code&gt; 和 &lt;code&gt;write&lt;/code&gt; 系统调用。文件映射的主要优点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;减少内核态和用户态之间的数据拷贝&lt;/strong&gt;：传统的文件读写操作需要在内核态和用户态之间进行数据拷贝，而文件映射可以直接在用户态访问文件内容，减少了数据拷贝的开销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高性能&lt;/strong&gt;：通过直接访问内存地址，文件映射可以显著提高文件读写操作的性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文件映射的工作原理&#34;&gt;&lt;a href=&#34;#%e6%96%87%e4%bb%b6%e6%98%a0%e5%b0%84%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;文件映射的工作原理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;打开文件&lt;/strong&gt;：程序通过 &lt;code&gt;open&lt;/code&gt; 系统调用打开文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;映射文件&lt;/strong&gt;：程序通过 &lt;code&gt;mmap&lt;/code&gt; 系统调用将文件内容映射到进程的地址空间。&lt;code&gt;mmap&lt;/code&gt; 系统调用会返回一个指针，指向映射的内存区域。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问文件内容&lt;/strong&gt;：程序可以通过指针直接访问文件内容，而无需调用 &lt;code&gt;read&lt;/code&gt; 或 &lt;code&gt;write&lt;/code&gt; 系统调用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;页缓存&#34;&gt;&lt;a href=&#34;#%e9%a1%b5%e7%bc%93%e5%ad%98&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;页缓存
&lt;/h2&gt;&lt;p&gt;操作系统会将文件的内容缓存在页缓存中。页缓存是内核管理的一块内存区域，用于缓存文件的页面。当程序通过文件映射访问文件内容时，操作系统会将文件的页面从磁盘加载到页缓存中，并将虚拟页面映射到页缓存中的物理页面。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CPU、进程、线程上下文切换</title>
        <link>/zh-cn/post/2025/08/cpu%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</link>
        <pubDate>Thu, 28 Aug 2025 19:22:50 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/08/cpu%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</guid>
        <description>&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/os/4_process/process_base.html#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2&#34;  title=&#34;5.1 进程、线程基础知识 | 小林coding | Java面试学习&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;5.1 进程、线程基础知识 | 小林 coding | Java 面试学习&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU 寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;位于&lt;strong&gt;CPU 核心&lt;/strong&gt;内部存储单元，用于暂存指令、数据、地址等信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU 缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;位于 CPU 和和主内存之间的存储单元，在 CPU 内部，有 L1、L2、L3 三级缓存，L1 容量最小，速度最快，通常集成在 &lt;strong&gt;CPU 核心&lt;/strong&gt;内部，L2、L3 次之。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/08/cpu%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/image.png&#34;
	width=&#34;869&#34;
	height=&#34;601&#34;
	srcset=&#34;/zh-cn/post/2025/08/cpu%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/image_hu_c7d2f9bac21c8962.png 480w, /zh-cn/post/2025/08/cpu%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/image_hu_3468b7822abc461d.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;144&#34;
		data-flex-basis=&#34;347px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;cpu-上下文切换&#34;&gt;&lt;a href=&#34;#cpu-%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;CPU 上下文切换
&lt;/h2&gt;&lt;p&gt;任务交给 CPU 运行，那么 CPU 需要知道任务从哪里加载、从哪里开始运行，所以操作系统需要事先帮 CPU 设置好 CPU 寄存器、程序计数器。&lt;/p&gt;
&lt;p&gt;CPU 上下文切换就是把前一个任务的上下文保存到寄存器和计数器，然后加载新的任务。这就包含了&lt;strong&gt;进程、线程、中断。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;进程上下文切换&#34;&gt;&lt;a href=&#34;#%e8%bf%9b%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;进程上下文切换
&lt;/h2&gt;&lt;p&gt;进程是由内核管理和调度的，所以&lt;strong&gt;进程的切换只能发生在内核态&lt;/strong&gt;。
&lt;img src=&#34;/zh-cn/post/2025/08/cpu%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/image-1.png&#34;
	width=&#34;917&#34;
	height=&#34;234&#34;
	srcset=&#34;/zh-cn/post/2025/08/cpu%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/image-1_hu_57ecf5298f63fd95.png 480w, /zh-cn/post/2025/08/cpu%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/image-1_hu_3c6b16e4d2421be.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;391&#34;
		data-flex-basis=&#34;940px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;进程上下文切换场景&#34;&gt;&lt;a href=&#34;#%e8%bf%9b%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2%e5%9c%ba%e6%99%af&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;进程上下文切换场景
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;当某个进程的时间片耗尽，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；&lt;/li&gt;
&lt;li&gt;进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候当前进程会被挂起，并由系统调度其他进程运行;&lt;/li&gt;
&lt;li&gt;当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；&lt;/li&gt;
&lt;li&gt;当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行;&lt;/li&gt;
&lt;li&gt;发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;线程上下文切换&#34;&gt;&lt;a href=&#34;#%e7%ba%bf%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;线程上下文切换
&lt;/h2&gt;&lt;p&gt;同一个进程内有多个线程，有共享内存和全局变量等资源，每个线程也有自己的寄存器和栈存放私有数据，各个线程可以并发执行。&lt;strong&gt;线程是 CPU 调度的基本单位，进程是资源分配的基本单位。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;当两个线程不属于同一个进程，则切换的过程就跟进程上下文切换一样；&lt;/li&gt;
&lt;li&gt;当两个线程属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，&lt;strong&gt;只需要切换线程的私有数据、寄存器等不共享的数据；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>服务器CPU飙升该如何排查&amp;火焰图</title>
        <link>/zh-cn/post/2025/06/%E6%9C%8D%E5%8A%A1%E5%99%A8cpu%E9%A3%99%E5%8D%87%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E7%81%AB%E7%84%B0%E5%9B%BE/</link>
        <pubDate>Tue, 10 Jun 2025 15:18:53 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/06/%E6%9C%8D%E5%8A%A1%E5%99%A8cpu%E9%A3%99%E5%8D%87%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E7%81%AB%E7%84%B0%E5%9B%BE/</guid>
        <description>&lt;h2 id=&#34;查看系统状态&#34;&gt;&lt;a href=&#34;#%e6%9f%a5%e7%9c%8b%e7%b3%bb%e7%bb%9f%e7%8a%b6%e6%80%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;&lt;strong&gt;查看系统状态&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;使用工具如&lt;code&gt;top&lt;/code&gt;、&lt;code&gt;htop&lt;/code&gt;、&lt;code&gt;ps&lt;/code&gt;等查看当前系统中&lt;strong&gt;各个进程的 CPU 使用情况&lt;/strong&gt;，确认是哪个进程导致 CPU 飙升。&lt;/p&gt;
&lt;h2 id=&#34;查看进程类型&#34;&gt;&lt;a href=&#34;#%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e7%b1%bb%e5%9e%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;&lt;strong&gt;查看进程类型&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;确定该进程是业务进程、系统进程还是其他类型&lt;/strong&gt;。如果是业务进程，进一步确认是哪个服务的进程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;使用 ps aux 列出所有进程的详细信息&lt;/li&gt;
&lt;li&gt;Linux 系统中，每个进程的信息都存储在 &lt;code&gt;/proc/&amp;lt;pid&amp;gt;&lt;/code&gt; 目录中。使用 cat 查看/proc 目录&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;查看该进程的日志&#34;&gt;&lt;a href=&#34;#%e6%9f%a5%e7%9c%8b%e8%af%a5%e8%bf%9b%e7%a8%8b%e7%9a%84%e6%97%a5%e5%bf%97&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;查看该进程的日志
&lt;/h2&gt;&lt;p&gt;了解是否有异常日志信息，比如频繁的错误、异常的请求等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;tail -f /var/log/&amp;lt;process_log_file&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;定位进程的线程&#34;&gt;&lt;a href=&#34;#%e5%ae%9a%e4%bd%8d%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%ba%bf%e7%a8%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;定位进程的线程
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;找到进程 ID（PID）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ps -ef | grep &amp;lt;进程名&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显示进程的所有线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ps -L&lt;/code&gt; 选项可以显示指定进程的所有线程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/06/%E6%9C%8D%E5%8A%A1%E5%99%A8cpu%E9%A3%99%E5%8D%87%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E7%81%AB%E7%84%B0%E5%9B%BE/image.png&#34;
	width=&#34;1446&#34;
	height=&#34;931&#34;
	srcset=&#34;/zh-cn/post/2025/06/%E6%9C%8D%E5%8A%A1%E5%99%A8cpu%E9%A3%99%E5%8D%87%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E7%81%AB%E7%84%B0%E5%9B%BE/image_hu_1e797ac9c2d04920.png 480w, /zh-cn/post/2025/06/%E6%9C%8D%E5%8A%A1%E5%99%A8cpu%E9%A3%99%E5%8D%87%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E7%81%AB%E7%84%B0%E5%9B%BE/image_hu_d960372203ebcfe2.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;155&#34;
		data-flex-basis=&#34;372px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;查看负载情况&#34;&gt;&lt;a href=&#34;#%e6%9f%a5%e7%9c%8b%e8%b4%9f%e8%bd%bd%e6%83%85%e5%86%b5&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;查看负载情况
&lt;/h2&gt;&lt;p&gt;检查是否有异常的流量涌入，导致进程负载过高。如果是由于流量过高导致的 CPU 飙升，可以尝试对流量进行控制，比如使用限流工具（如&lt;code&gt;nginx&lt;/code&gt;的限流模块、&lt;code&gt;iptables&lt;/code&gt;等）减少进入该服务的流量。&lt;/p&gt;
&lt;h2 id=&#34;紧急处理&#34;&gt;&lt;a href=&#34;#%e7%b4%a7%e6%80%a5%e5%a4%84%e7%90%86&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;紧急处理
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优先级调整&lt;/strong&gt;：如果进程是业务进程且不能立即停止，可以尝试降低该进程的优先级，使用&lt;code&gt;nice&lt;/code&gt;或&lt;code&gt;renice&lt;/code&gt;命令，减少其对 CPU 的占用，从而让其他服务能够正常运行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;renice -n 10 -p &amp;lt;pid&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;临时隔离&lt;/strong&gt;：如果该进程是某个服务的实例，可以尝试将该实例从负载均衡中移除，让其他正常实例继续提供服务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;详细排查&#34;&gt;&lt;a href=&#34;#%e8%af%a6%e7%bb%86%e6%8e%92%e6%9f%a5&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;详细排查
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;火焰图分析&lt;/strong&gt;：使用火焰图工具（如&lt;code&gt;perf&lt;/code&gt;、&lt;code&gt;flamegraph&lt;/code&gt;等）分析进程的 CPU 使用情况，找到具体的瓶颈点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo perf record -g -p &amp;lt;pid&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo perf script | stackcollapse-perf.pl | flamegraph.pl &amp;gt; flamegraph.svg
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码分析&lt;/strong&gt;：根据火焰图的分析结果，定位到具体的代码位置，查看是否有逻辑问题，如死循环、高复杂度算法等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;依赖检查&lt;/strong&gt;：检查该进程是否依赖了其他服务或资源，是否存在依赖服务响应慢导致的阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;恢复与优化&#34;&gt;&lt;a href=&#34;#%e6%81%a2%e5%a4%8d%e4%b8%8e%e4%bc%98%e5%8c%96&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;恢复与优化
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;恢复服务&lt;/strong&gt;：如果经过分析确认该进程确实有问题且无法快速修复，可以考虑重启该进程，但在此之前确保有备份和回滚方案。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化代码&lt;/strong&gt;：根据分析结果，对代码进行优化，减少 CPU 使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源扩展&lt;/strong&gt;：如果是因为资源不足导致的 CPU 飙升，可以考虑增加服务器资源，如 CPU、内存等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;火焰图&#34;&gt;&lt;a href=&#34;#%e7%81%ab%e7%84%b0%e5%9b%be&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;火焰图
&lt;/h2&gt;&lt;p&gt;火焰图工具不是 linux 自带的，需要下载安装。&lt;/p&gt;
&lt;h3 id=&#34;安装-perf-工具&#34;&gt;&lt;a href=&#34;#%e5%ae%89%e8%a3%85-perf-%e5%b7%a5%e5%85%b7&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;安装  &lt;code&gt;perf&lt;/code&gt;  工具
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;perf&lt;/code&gt; 是 Linux 系统中用于性能分析的工具，通常可以通过包管理器安装。&lt;/p&gt;
&lt;h3 id=&#34;下载和安装-flamegraph-工具&#34;&gt;&lt;a href=&#34;#%e4%b8%8b%e8%bd%bd%e5%92%8c%e5%ae%89%e8%a3%85-flamegraph-%e5%b7%a5%e5%85%b7&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;下载和安装 FlameGraph 工具
&lt;/h3&gt;&lt;p&gt;FlameGraph 是由 Brendan Gregg 开发的工具集，用于将 &lt;code&gt;perf&lt;/code&gt; 的输出转换为火焰图。&lt;/p&gt;
&lt;h3 id=&#34;生成火焰图&#34;&gt;&lt;a href=&#34;#%e7%94%9f%e6%88%90%e7%81%ab%e7%84%b0%e5%9b%be&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;生成火焰图
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;使用 &lt;code&gt;perf record&lt;/code&gt; 命令捕获性能数据。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如，以下命令会在 60 秒内从所有 CPU 和进程生成性能样本：&lt;/p&gt;
&lt;p&gt;perf record -a -g -F 99 sleep 60&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-a&lt;/code&gt;：从所有 CPU 捕获数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-g&lt;/code&gt;：启用调用图收集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-F 99&lt;/code&gt;：每秒采样 99 次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sleep 60&lt;/code&gt;：运行 60 秒后停止捕获。&lt;/p&gt;
&lt;p&gt;2. &lt;strong&gt;将性能数据转换为文本格式&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;perf script &amp;gt; data.perf&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;生成 SVG 格式的火焰图&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 &lt;code&gt;flamegraph.pl&lt;/code&gt; 脚本生成 SVG 格式的火焰图&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>用户态和内核态、进程、协程及线程几种状态、DMA、零拷贝</title>
        <link>/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/</link>
        <pubDate>Sat, 18 Jan 2025 12:00:00 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/</guid>
        <description>&lt;h2 id=&#34;用户态和内核态&#34;&gt;&lt;a href=&#34;#%e7%94%a8%e6%88%b7%e6%80%81%e5%92%8c%e5%86%85%e6%a0%b8%e6%80%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;用户态和内核态
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;根据&lt;strong&gt;进程访问资源的特点&lt;/strong&gt;，我们可以把进程在系统上的运行分为两个级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户态(User Mode)&lt;/strong&gt; : 用户态运行的进程可以&lt;strong&gt;直接读取用户程序的数据&lt;/strong&gt; ，拥有较低的权限。当应用程序需要执行某些&lt;strong&gt;需要特殊权限的操作&lt;/strong&gt; ，例如读写磁盘、网络通信等，就需要&lt;strong&gt;向操作系统发起系统调用请求，进入内核态&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核态(Kernel Mode)&lt;/strong&gt; ：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会&lt;strong&gt;从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程&lt;/strong&gt;，最后再从内核态切换回用户态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过，由于切换内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查），应该尽量减少进入内核态的次数，以提高系统的性能和稳定性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image.png&#34;
	width=&#34;1296&#34;
	height=&#34;515&#34;
	srcset=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image_hu_1e870b4c92582ebc.png 480w, /zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image_hu_eea5689c43ae9380.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;251&#34;
		data-flex-basis=&#34;603px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;用户态和内核态如何切换&#34;&gt;&lt;a href=&#34;#%e7%94%a8%e6%88%b7%e6%80%81%e5%92%8c%e5%86%85%e6%a0%b8%e6%80%81%e5%a6%82%e4%bd%95%e5%88%87%e6%8d%a2&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;用户态和内核态如何切换
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;用户态切换到内核态的 3 种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;系统调用（Trap）&lt;/strong&gt; ：用户态进程 &lt;strong&gt;主动&lt;/strong&gt; 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。
&lt;img src=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-1.png&#34;
	width=&#34;1308&#34;
	height=&#34;299&#34;
	srcset=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-1_hu_f1eaf03a23ee5160.png 480w, /zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-1_hu_70a47b0b4732d40d.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;437&#34;
		data-flex-basis=&#34;1049px&#34;
	
&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断（Interrupt）&lt;/strong&gt; ：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会&lt;strong&gt;暂停&lt;/strong&gt;执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常（Exception）&lt;/strong&gt;：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;进程和线程&#34;&gt;&lt;a href=&#34;#%e8%bf%9b%e7%a8%8b%e5%92%8c%e7%ba%bf%e7%a8%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;进程和线程
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程（Process）&lt;/strong&gt; 是指计算机中正在运行的一个程序实例。比如打开某个应用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程（Thread）&lt;/strong&gt; 轻量级进程，多个线程可以在同一个进程中同时执行，并且&lt;strong&gt;共享进程的资源&lt;/strong&gt;比如内存空间、文件句柄、网络连接等。举例：你打开的微信里就有一个线程专门用来拉取别人发你的最新的消息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协程&lt;/strong&gt; 是一种&lt;strong&gt;用户态&lt;/strong&gt; 的&lt;strong&gt;轻量级线程&lt;/strong&gt; ，其调度完全由用户程序控制，而不需要内核的参与。协程拥有自己的寄存器上下文和栈，但与其他协程共享堆内存。协程的切换开销非常小，因为只需要保存和恢复协程的上下文，而无需进行内核级的上下文切换。这使得协程在处理大量并发任务时具有非常高的效率。然而，协程需要程序员显式地进行调度和管理，相对于线程和进程来说，其编程模型更为复杂。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-2.png&#34;
	width=&#34;560&#34;
	height=&#34;680&#34;
	srcset=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-2_hu_9f85a8bca5f21f7b.png 480w, /zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-2_hu_9cdbd67f210a030c.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;82&#34;
		data-flex-basis=&#34;197px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;进程的几种状态&#34;&gt;&lt;a href=&#34;#%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%87%a0%e7%a7%8d%e7%8a%b6%e6%80%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;进程的几种状态
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;和线程的状态很像&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建状态(new)&lt;/strong&gt;：进程正在被创建，尚未到就绪状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;就绪状态(ready)&lt;/strong&gt;：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行状态(running)&lt;/strong&gt;：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞状态(waiting)&lt;/strong&gt;：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结束状态(terminated)&lt;/strong&gt;：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建状态和就绪状态的区别：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;状态&lt;/th&gt;
          &lt;th&gt;通俗理解&lt;/th&gt;
          &lt;th&gt;线程内部发生了什么&lt;/th&gt;
          &lt;th&gt;是否能被调度&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;创建（NEW）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;只是&amp;quot;生成了车票&amp;quot;，还没进站&lt;/td&gt;
          &lt;td&gt;已 &lt;code&gt;new Thread()&lt;/code&gt;，&lt;strong&gt;但未调用 &lt;code&gt;start()&lt;/code&gt;&lt;/strong&gt; ，&lt;strong&gt;操作系统线程尚未真正创建&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;❌ 调度器看不见，进不了就绪队列&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;就绪（RUNNABLE）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;已进站，在候车大厅排队&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;调用了 &lt;code&gt;start()&lt;/code&gt;&lt;/strong&gt;，操作系统线程已建立，所有资源到位，等待 CPU 时间片&lt;/td&gt;
          &lt;td&gt;✅ 随时可能被调度器挑中执行&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;dmadirect-memory-access&#34;&gt;&lt;a href=&#34;#dmadirect-memory-access&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;DMA（direct memory access）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在没有 DMA 技术之前，I/O 过程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;用户进程发起 read 调用，切换用户态到内核态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU 发出 I/O 请求给磁盘控制器，然后返回&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁盘控制器收到请求开始准备数据，把数据放到磁盘控制器的内部缓冲区，然后产生一个中断&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU 收到中断信号，停下手头的工作，把磁盘控制器缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的&lt;/strong&gt; &amp;gt;&lt;img src=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-3.png&#34;
	width=&#34;1276&#34;
	height=&#34;763&#34;
	srcset=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-3_hu_735dc43254f3eed9.png 480w, /zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-3_hu_8ac3b3ffd6b0daba.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;167&#34;
		data-flex-basis=&#34;401px&#34;
	
&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由上可见整个数据传输过程中，都需要 CPU 亲自参与，期间 cpu 不能做其他事，非常拉低性能。于是有了 DMA。
&lt;img src=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-4.png&#34;
	width=&#34;1282&#34;
	height=&#34;647&#34;
	srcset=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-4_hu_213a398399d99644.png 480w, /zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-4_hu_59d9120ee1bee128.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;198&#34;
		data-flex-basis=&#34;475px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;传统的文件传输&#34;&gt;&lt;a href=&#34;#%e4%bc%a0%e7%bb%9f%e7%9a%84%e6%96%87%e4%bb%b6%e4%bc%a0%e8%be%93&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;传统的文件传输
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;进程文件传输，最简单的方式就是把磁盘文件读取出来，通过网络协议发出去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-5.png&#34;
	width=&#34;1265&#34;
	height=&#34;818&#34;
	srcset=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-5_hu_fdbbc5d9c80ad1ad.png 480w, /zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-5_hu_758182a1e548295.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;154&#34;
		data-flex-basis=&#34;371px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;期间发生&lt;strong&gt;四次&lt;/strong&gt; 用户态和内核态的切换，因为发生了两次系统调用，一次是 &lt;code&gt;read()&lt;/code&gt; ，一次是 &lt;code&gt;write()&lt;/code&gt;每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;如何优化文件传输性能&#34;&gt;&lt;a href=&#34;#%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96%e6%96%87%e4%bb%b6%e4%bc%a0%e8%be%93%e6%80%a7%e8%83%bd&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;如何优化文件传输性能
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在读取磁盘数据的时候之所以要发生上下文切换，是因为用户空间没有权限操作磁盘或网卡，需要切换到内核态来完成，而&lt;strong&gt;一次系统调用必然发生两次上下文切换&lt;/strong&gt;：用户到内核、内核到用户，所以要减少上下文切换次数，就要减少系统调用次数！&lt;/p&gt;
&lt;p&gt;在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，从内核&lt;/p&gt;
&lt;p&gt;的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里，&lt;/p&gt;
&lt;p&gt;这个过程是没有必要的。因为文件传输的应用场景中，&lt;strong&gt;在用户空间我们并不会对数据再加工，所以数据实际上可以不用搬运到用户空间，因此用户的缓冲区是没有必要存在的&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;如何实现零拷贝&#34;&gt;&lt;a href=&#34;#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e9%9b%b6%e6%8b%b7%e8%b4%9d&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;如何实现零拷贝
&lt;/h3&gt;&lt;h4 id=&#34;mmap--write&#34;&gt;&lt;a href=&#34;#mmap--write&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;mmap + write
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在前面我们知道，read()系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，可以用&lt;strong&gt;mmap()替换 read()系统&lt;/strong&gt;调用函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mmap()&lt;/code&gt; 系统调用函数会直接把内核缓冲区里的数据「&lt;strong&gt;映射&lt;/strong&gt;」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-6.png&#34;
	width=&#34;1269&#34;
	height=&#34;851&#34;
	srcset=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-6_hu_be3ea3a89fd51ba3.png 480w, /zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-6_hu_8f8e6390534ed0fe.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;149&#34;
		data-flex-basis=&#34;357px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这种方式仍然是两次系统调用，四次上下文切换，只不过少了 1 次拷贝。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;sendfile&#34;&gt;&lt;a href=&#34;#sendfile&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;sendfile
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;linux 内核 2.1&lt;/strong&gt;中的 sendfile 是专门发送文件的系统调用函数，仅有一次系统调用，可以代替 read 和 write 两次系统调用。该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-7.png&#34;
	width=&#34;1290&#34;
	height=&#34;860&#34;
	srcset=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-7_hu_c6c8873726b01c61.png 480w, /zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-7_hu_863e5bf9a84bda48.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;150&#34;
		data-flex-basis=&#34;360px&#34;
	
&gt; &amp;gt; &lt;strong&gt;linux 内核 &lt;code&gt;2.4&lt;/code&gt;&lt;/strong&gt; ，在网卡支持 SG-DMA 的情况下，可以用 sendfile 直接把文件从内核缓冲区拷贝到网卡。这才是真正的零拷贝，&lt;strong&gt;因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-8.png&#34;
	width=&#34;1290&#34;
	height=&#34;824&#34;
	srcset=&#34;/zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-8_hu_deba7015a73b5c0d.png 480w, /zh-cn/post/2025/01/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81dma%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-8_hu_c009fa096b79d6b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;156&#34;
		data-flex-basis=&#34;375px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;pagecache&#34;&gt;&lt;a href=&#34;#pagecache&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;PageCache
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;回顾前面说道文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲&lt;/p&gt;
&lt;p&gt;区」里，这个「内核缓冲区」实际上是磁盘高速缓存(PageCache)。&lt;/p&gt;
&lt;p&gt;PageCache 会缓存&lt;strong&gt;最近被访问的数据&lt;/strong&gt; （把磁盘数据读到缓存中），来提高读写性能。同时会进行&lt;strong&gt;预读&lt;/strong&gt;，比如实际要从磁盘读取 32kb 数据，那么内核会把 32-64kb 的数据也提前读到缓存。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
