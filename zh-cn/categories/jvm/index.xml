<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>JVM on 青秋博客</title>
        <link>/zh-cn/categories/jvm/</link>
        <description>Recent content in JVM on 青秋博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>青秋博客</copyright>
        <lastBuildDate>Sat, 30 Aug 2025 15:10:58 +0000</lastBuildDate><atom:link href="/zh-cn/categories/jvm/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>String str = new String(“abc“)</title>
        <link>/zh-cn/post/2025/08/string-str-new-stringabc/</link>
        <pubDate>Sat, 30 Aug 2025 15:10:58 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/08/string-str-new-stringabc/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;new 出来的对象和这个对象的引用 str，字符串的值 abc，这三个元素分别放在哪里？&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;字符串 abc 存在字符串常量池中，位于&lt;strong&gt;方法区&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;创建的 String 对象位于&lt;strong&gt;堆内存&lt;/strong&gt;，对象包含字符串的内容 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;，但它是一个独立的对象，与字符串常量池中的对象不同。首次创建 String 对象时，字符串常量池并没有 abc，那么会在字符串常量池创建 abc 字符串，然后获取其引用，最终在&lt;strong&gt;堆中&lt;/strong&gt;创建了一个&amp;quot;abc&amp;quot;的 String 对象；第二次创建 String 对象时，会先去常量池找有没有字符串 abc，找到了就获取其引用，然后创建新的 String 对象。&lt;/li&gt;
&lt;li&gt;引用变量 &lt;code&gt;a&lt;/code&gt; 是一个指向 &lt;code&gt;String&lt;/code&gt; 对象的引用。它&lt;strong&gt;存储了 &lt;code&gt;String&lt;/code&gt; 对象的内存地址，而不是对象本身的内容&lt;/strong&gt;。引用变量 &lt;code&gt;a&lt;/code&gt; 本身是一个局部变量，&lt;strong&gt;存储在当前线程的栈内存&lt;/strong&gt;中。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>线程崩溃了，所属进程也会崩溃吗</title>
        <link>/zh-cn/post/2025/08/%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BA%86%E6%89%80%E5%B1%9E%E8%BF%9B%E7%A8%8B%E4%B9%9F%E4%BC%9A%E5%B4%A9%E6%BA%83%E5%90%97/</link>
        <pubDate>Sat, 30 Aug 2025 15:03:04 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/08/%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BA%86%E6%89%80%E5%B1%9E%E8%BF%9B%E7%A8%8B%E4%B9%9F%E4%BC%9A%E5%B4%A9%E6%BA%83%E5%90%97/</guid>
        <description>&lt;p&gt;&lt;strong&gt;一般来说&lt;/strong&gt;，线程如果因为非法访问内存引发崩溃，那么进程也会崩溃，因为各个线程的地址空间共享，非法访问内存会影响其他线程，引发严重后果。&lt;/p&gt;
&lt;h2 id=&#34;进程如何崩溃&#34;&gt;&lt;a href=&#34;#%e8%bf%9b%e7%a8%8b%e5%a6%82%e4%bd%95%e5%b4%a9%e6%ba%83&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;进程如何崩溃
&lt;/h2&gt;&lt;p&gt;进程崩溃是通过&lt;strong&gt;信号&lt;/strong&gt;实现的，常用的 kill -9 就是直接给指定进程 pid 发送终止信号 9。&lt;/p&gt;
&lt;h2 id=&#34;cc-中线程崩溃导致进程崩溃的原因&#34;&gt;&lt;a href=&#34;#cc-%e4%b8%ad%e7%ba%bf%e7%a8%8b%e5%b4%a9%e6%ba%83%e5%af%bc%e8%87%b4%e8%bf%9b%e7%a8%8b%e5%b4%a9%e6%ba%83%e7%9a%84%e5%8e%9f%e5%9b%a0&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;C/C++ 中线程崩溃导致进程崩溃的原因
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非法内存访问&lt;/strong&gt;：如果线程因为非法访问内存（如访问未分配的内存、写入只读内存等）而崩溃，操作系统会发送 &lt;code&gt;SIGSEGV&lt;/code&gt; 信号给进程。默认情况下，操作系统会终止整个进程，因为这种错误可能会导致进程的地址空间处于不稳定状态，影响其他线程的运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信号处理机制&lt;/strong&gt;：操作系统通过信号机制处理线程的崩溃。如果进程没有定义自己的信号处理函数，操作系统会执行默认的信号处理程序，导致进程退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java-中线程崩溃不会导致-jvm-崩溃的原因&#34;&gt;&lt;a href=&#34;#java-%e4%b8%ad%e7%ba%bf%e7%a8%8b%e5%b4%a9%e6%ba%83%e4%b8%8d%e4%bc%9a%e5%af%bc%e8%87%b4-jvm-%e5%b4%a9%e6%ba%83%e7%9a%84%e5%8e%9f%e5%9b%a0&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Java 中线程崩溃不会导致 JVM 崩溃的原因
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JVM 的信号处理机制&lt;/strong&gt;：&lt;strong&gt;JVM 定义了自己的信号处理函数，拦截了 &lt;code&gt;SIGSEGV&lt;/code&gt; 等信号。当线程崩溃时，JVM 会捕获这些信号，并进行内部处理，而不是直接终止整个进程。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常处理机制&lt;/strong&gt;：在 Java 中，线程崩溃通常会抛出异常（如 &lt;code&gt;NullPointerException&lt;/code&gt; 或 &lt;code&gt;StackOverflowError&lt;/code&gt;）。JVM 会捕获这些异常并进行处理，而不是直接终止整个 JVM。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>符号引用和直接引用、强引用、软引用、弱引用、虚引用</title>
        <link>/zh-cn/post/2025/02/%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%BC%BA%E5%BC%95%E7%94%A8%E8%BD%AF%E5%BC%95%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%E8%99%9A%E5%BC%95%E7%94%A8/</link>
        <pubDate>Thu, 13 Feb 2025 14:03:21 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/02/%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%BC%BA%E5%BC%95%E7%94%A8%E8%BD%AF%E5%BC%95%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%E8%99%9A%E5%BC%95%E7%94%A8/</guid>
        <description>&lt;h2 id=&#34;符号引用&#34;&gt;&lt;a href=&#34;#%e7%ac%a6%e5%8f%b7%e5%bc%95%e7%94%a8&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;符号引用
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;以一组符号来描述所引用的目标。&lt;/li&gt;
&lt;li&gt;符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。&lt;/li&gt;
&lt;li&gt;为什么要有符号引用？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;java 类被编译成 class 文件时，&lt;strong&gt;虚拟机并不知道所引用类的地址，所以就用符号引用来代替&lt;/strong&gt; ，而在&lt;strong&gt;链接的解析阶段&lt;/strong&gt; 就是为了把这个符号引用转化成为&lt;strong&gt;真正的地址即直接引用&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;直接引用&#34;&gt;&lt;a href=&#34;#%e7%9b%b4%e6%8e%a5%e5%bc%95%e7%94%a8&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;直接引用
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;直接引用和虚拟机的布局是相关的，&lt;strong&gt;不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;直接引用可以是指向对象，类变量和类方法的指针、相对偏移量、一个间接定位到对象的句柄。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;强引用&#34;&gt;&lt;a href=&#34;#%e5%bc%ba%e5%bc%95%e7%94%a8&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;强引用
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;把一个对象赋给一个引用变量，如 MikeChen mikechen=new MikeChen();&lt;/p&gt;
&lt;p&gt;在一个方法的内部有一个强引用，这个引用保存在 Java 栈中，而真正的引用内容(MikeChen)保存在 Java 堆中。
&lt;img src=&#34;/zh-cn/post/2025/02/%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%BC%BA%E5%BC%95%E7%94%A8%E8%BD%AF%E5%BC%95%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%E8%99%9A%E5%BC%95%E7%94%A8/image.png&#34;
	width=&#34;459&#34;
	height=&#34;227&#34;
	srcset=&#34;/zh-cn/post/2025/02/%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%BC%BA%E5%BC%95%E7%94%A8%E8%BD%AF%E5%BC%95%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%E8%99%9A%E5%BC%95%E7%94%A8/image_hu_7d26d6f45ca54fb9.png 480w, /zh-cn/post/2025/02/%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%BC%BA%E5%BC%95%E7%94%A8%E8%BD%AF%E5%BC%95%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%E8%99%9A%E5%BC%95%E7%94%A8/image_hu_b86061009e21df65.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;202&#34;
		data-flex-basis=&#34;485px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;如果一个对象具有强引用，即使 OOM 垃圾回收器不会回收该对象，如果强引用对象不使用时，需要弱化从而使 GC 能够回收，如 mikechen=null;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;软引用soft&#34;&gt;&lt;a href=&#34;#%e8%bd%af%e5%bc%95%e7%94%a8soft&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;软引用（Soft）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference 类来实现：
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;String str=new String(&amp;#34;abc&amp;#34;); // 强引用
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SoftReference&amp;lt;String&amp;gt; softRef=new SoftReference&amp;lt;String&amp;gt;(str);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;内存不足时就会回收该对象内存，gc 不一定回收&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;弱引用weak&#34;&gt;&lt;a href=&#34;#%e5%bc%b1%e5%bc%95%e7%94%a8weak&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;弱引用（Weak）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;不管内存是否足够，只要发生 GC，都会被回收。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用 System.gc()方法只是起通知作用，不一定立刻 gc&lt;/strong&gt;，JVM 的 gc 时机由 JVM 自己的状态决定。&lt;/p&gt;
&lt;p&gt;比如 ThreadLocal 的静态内部类 Entry 就继承了弱引用，ThreadLocalMap 使用 ThreadLocal 的弱引用作为 key，GC 时这个 ThreadLocal 势必会被回收，这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry，就没有办法访问这些 key 为 null 的 Entry 的 value，也就造成内存泄漏。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;虚引用phantom&#34;&gt;&lt;a href=&#34;#%e8%99%9a%e5%bc%95%e7%94%a8phantom&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;虚引用（Phantom）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;虚引用（Phantom Reference）是 Java 中最弱的引用类型，&lt;strong&gt;无法通过引用直接获取到对象实例&lt;/strong&gt; 。虚引用主要用于&lt;strong&gt;跟踪对象被垃圾回收的状态&lt;/strong&gt;。当一个对象只被虚引用关联时，其实际上并不影响对象的生命周期，也就是说，垃圾回收器随时可能回收被虚引用关联的对象。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>字符串常量池</title>
        <link>/zh-cn/post/2025/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</link>
        <pubDate>Fri, 07 Feb 2025 12:00:00 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/image.png&#34;
	width=&#34;1418&#34;
	height=&#34;771&#34;
	srcset=&#34;/zh-cn/post/2025/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/image_hu_3473df186a016605.png 480w, /zh-cn/post/2025/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/image_hu_91c6fc291ca360c1.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;183&#34;
		data-flex-basis=&#34;441px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/image-1.png&#34;
	width=&#34;1750&#34;
	height=&#34;1088&#34;
	srcset=&#34;/zh-cn/post/2025/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/image-1_hu_39267bcfe5d5801a.png 480w, /zh-cn/post/2025/02/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/image-1_hu_125efa2f2ce762f3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;160&#34;
		data-flex-basis=&#34;386px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;String s=&lt;strong&gt;new String(&amp;ldquo;abc&amp;rdquo;)时，&lt;/strong&gt; 虚拟机会先去字符串常量池查找有无 abc 这个字符串对象，如果有就不在字符串常量池创建了，直接在堆中创建一个 abc 字符串对象，然后将&lt;strong&gt;堆中这个 abc 的对象地址&lt;/strong&gt; 返回赋值给变量，如果没有，则先在字符串常量池创建字符串 abc，然后在堆中创建 abc 的字符串对象，然后将&lt;strong&gt;堆中这个 abc 的对象地址&lt;/strong&gt;返回赋值给变量。&lt;/p&gt;
&lt;p&gt;java 的栈上存储的是基本数据类型的变量和对象的引用，而对象本身则存储在堆上。
&lt;strong&gt;为什么要先在字符串常量池中创建对象，然后再在堆上创建呢&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;通常我们会用双引号的方式创建字符串对象，而不是 new 关键字，此时虚拟机会先在字符串常量池中查找有没有&amp;quot;abc&amp;quot;这个字符串对象，如果有，则不创建任何对象，直接将字符串常量池中这个&amp;quot;abc&amp;quot;的对象地址返回，赋给变量 s；如果没有，在字符串常量池中创建&amp;quot;abc&amp;quot;这个对象，然后将其地址返回，赋给变量 s。此时就不用在堆中创建对象了
String s = new String(&amp;ldquo;abc&amp;rdquo;); String s1 = new String(&amp;ldquo;abc&amp;rdquo;);&lt;/p&gt;
&lt;p&gt;这两行代码会创建三个对象，字符串常量池一个、堆上两个。&lt;/p&gt;
&lt;p&gt;String s = &amp;ldquo;abc&amp;rdquo;; String s1 = &amp;ldquo;abc&amp;rdquo;;&lt;/p&gt;
&lt;p&gt;这两行代码只会创建一个对象，就是字符串常量池中的那个。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>JVM图文入门</title>
        <link>/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/</link>
        <pubDate>Thu, 06 Feb 2025 12:00:00 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/</guid>
        <description>&lt;h2 id=&#34;jvm8-结构图&#34;&gt;&lt;a href=&#34;#jvm8-%e7%bb%93%e6%9e%84%e5%9b%be&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;JVM8 结构图
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image.png&#34;
	width=&#34;1080&#34;
	height=&#34;608&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image_hu_46f6ee758ed7ca7a.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image_hu_131334b1e926ad24.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;java-性能低的主要原因&#34;&gt;&lt;a href=&#34;#java-%e6%80%a7%e8%83%bd%e4%bd%8e%e7%9a%84%e4%b8%bb%e8%a6%81%e5%8e%9f%e5%9b%a0&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Java 性能低的主要原因
&lt;/h2&gt;&lt;p&gt;Java 语言如果不做任何的优化，性能其实是不如 C 和 C++语言的。主要原因是：&lt;/p&gt;
&lt;p&gt;在程序运行过程中，Java 虚拟机需要将字节码指令&lt;strong&gt;实时&lt;/strong&gt; 地解释成计算机能识别的机器码，这个过程在运行时可能会&lt;strong&gt;反复执行&lt;/strong&gt;，所以效率较低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-1.png&#34;
	width=&#34;1015&#34;
	height=&#34;233&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-1_hu_347f13640686e050.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-1_hu_eaff55ae80c0257b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;435&#34;
		data-flex-basis=&#34;1045px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;C 和 C++语言在执行过程中，只需将源代码编译成可执行文件，就包含了计算机能识别的机器码，无需在运行过程中再实时地解释，所以性能较高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-2.png&#34;
	width=&#34;746&#34;
	height=&#34;212&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-2_hu_361ff32737e75daf.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-2_hu_200d172619a4a38e.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;351&#34;
		data-flex-basis=&#34;844px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Java 为什么要选择一条执行效率比较低的方式呢？主要是为了实现&lt;strong&gt;跨平台&lt;/strong&gt;的特性。Java 的字节码指令，如果希望在不同平台（操作系统+硬件架构），比如在 windows 或者 linux 上运行。可以使用同一份字节码指令，交给 windows 和 linux 上的 Java 虚拟机进行解释，这样就可以获得不同平台上的机器码了。这样就实现了 Write Once，Run Anywhere 编写一次，到处运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-3.png&#34;
	width=&#34;1255&#34;
	height=&#34;473&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-3_hu_9816902d7381a6a8.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-3_hu_f6f44c90ff4d8ced.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;265&#34;
		data-flex-basis=&#34;636px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;字节码文件&#34;&gt;&lt;a href=&#34;#%e5%ad%97%e8%8a%82%e7%a0%81%e6%96%87%e4%bb%b6&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;字节码文件
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-4.png&#34;
	width=&#34;1480&#34;
	height=&#34;922&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-4_hu_8ed7fe40d5120771.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-4_hu_95f36f6b3f1fae05.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;160&#34;
		data-flex-basis=&#34;385px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;我们 java 中说的字节码文件即 java 代码编译后的.class 文件，class 文件可以跨平台运行在不同操作系统的 JVM 上。&lt;/p&gt;
&lt;h3 id=&#34;字节码文件的组成&#34;&gt;&lt;a href=&#34;#%e5%ad%97%e8%8a%82%e7%a0%81%e6%96%87%e4%bb%b6%e7%9a%84%e7%bb%84%e6%88%90&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;字节码文件的组成
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;字节码文件总共可以分为以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基础信息：魔数、字节码文件对应的 Java 版本号、访问标识(public final 等等)、父类和接口信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常量池：保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字段：当前类或接口声明的字段信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法：当前类或接口声明的方法信息，核心内容为方法的字节码指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;属性：类的属性，比如源码的文件名、内部类的列表等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;jvm-架构&#34;&gt;&lt;a href=&#34;#jvm-%e6%9e%b6%e6%9e%84&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;JVM 架构
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;根据上面的 JVM 图，JVM 大致可分为三块： 类加载器 ClassLoader、运行时数据区 、执行引擎&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;类加载器-classloader&#34;&gt;&lt;a href=&#34;#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8-classloader&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;类加载器 ClassLoader
&lt;/h3&gt;&lt;p&gt;类加载器会通过二进制流的方式获取到字节码文件并交给 Java 虚拟机，虚拟机会在方法区和堆上生成对应的对象保存字节码信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;根加载器（启动类加载器）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认加载 Java 安装目录/jre/lib 下的类文件，比如 rt.jar，tools.jar，resources.jar 等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展类加载器：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认加载 Java 安装目录/jre/lib/ext 下的类文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用程序类加载器（系统类加载器）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认加载的是项目中的类以及通过 maven 引入的第三方 jar 包中的类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户自定义类加载器&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-5.png&#34;
	width=&#34;1548&#34;
	height=&#34;928&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-5_hu_fcceb1d930b3027d.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-5_hu_20987d3d3435dba.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;166&#34;
		data-flex-basis=&#34;400px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出为 null 是因为根加载器的具体实现是由 C 或 C++编写，不在 java 范围内。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;运行时数据区&#34;&gt;&lt;a href=&#34;#%e8%bf%90%e8%a1%8c%e6%97%b6%e6%95%b0%e6%8d%ae%e5%8c%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;运行时数据区
&lt;/h3&gt;&lt;p&gt;运行时数据可以划分为以下 5 块
&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-6.png&#34;
	width=&#34;1280&#34;
	height=&#34;479&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-6_hu_2caeff63a4e09813.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-6_hu_18037f613a968853.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;267&#34;
		data-flex-basis=&#34;641px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;程序计数器&#34;&gt;&lt;a href=&#34;#%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;程序计数器
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;每个线程都有一个私有的程序计数器，也就是一个指针，指向方法区中的方法字节码（用来存储指向指令的地址）。解释器会在工作的时候改变这个计数器的值来选取下一条需要执行的字节码指令。如果线程执行的是非本地方法，则程序计数器中保存的是当前需要执行的指令地址；如果线程执行的是本地方法，则程序计数器中的值是 undefined。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;java-虚拟机栈方法栈&#34;&gt;&lt;a href=&#34;#java-%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88%e6%96%b9%e6%b3%95%e6%a0%88&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Java 虚拟机栈(方法栈)
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;栈中没有垃圾回收的，线程结束后内存会自动释放。栈主管程序运行、生命周期、线程同步。&lt;/p&gt;
&lt;p&gt;Java 虚拟机栈中是一个个栈帧，每个栈帧对应一个被调用的方法，当线程执行一个方法时，会创建一个对应的栈帧，并将栈帧压入栈中。当方法执行完毕后，将栈帧从栈中弹出。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;栈帧及组成&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;局部变量表，局部变量表的作用是在运行过程中存放所有的局部变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作数栈，操作数栈是栈帧中虚拟机在执行指令过程中用来存放临时数据的一块区域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;帧数据，帧数据主要包含动态链接、方法出口、异常表的引用
&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-7.png&#34;
	width=&#34;1367&#34;
	height=&#34;1119&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-7_hu_44501e0b13d385ee.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-7_hu_f6aac7324af3dac2.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;122&#34;
		data-flex-basis=&#34;293px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;stack1 的方法结束后要弹出栈，此时需要通过 stack1 返回下面的 stack2 的方法。&lt;/p&gt;
&lt;h4 id=&#34;本地方法栈&#34;&gt;&lt;a href=&#34;#%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;本地方法栈
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Java 虚拟机栈存储了 Java 方法调用时的栈帧，而本地方法栈存储的是 native 本地方法的栈帧&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;堆&#34;&gt;&lt;a href=&#34;#%e5%a0%86&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;堆
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Student&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Student&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;张三&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;printTotalScore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;printAverageScore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Student&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Student&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;李四&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;19&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;printTotalScore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;printAverageScore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这段代码中通过&lt;code&gt;new&lt;/code&gt;关键字创建了两个&lt;code&gt;Student&lt;/code&gt;类的对象，这两个对象会被存放在堆上。在栈上通过&lt;code&gt;s1&lt;/code&gt;和&lt;code&gt;s2&lt;/code&gt;两个局部变量保存堆上两个对象的地址，从而实现了引用关系的建立。
&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-8.png&#34;
	width=&#34;719&#34;
	height=&#34;377&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-8_hu_d82dcdf42608b78d.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-8_hu_f4a6280f2ceaa9e3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;190&#34;
		data-flex-basis=&#34;457px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;以前的 Java 中&amp;quot;几乎&amp;quot;所有的对象都会在堆中分配，但随着 JIT 编译器的发展和逃逸技术的逐渐成熟，所有的对象都分配到堆上渐渐变得不那么&amp;quot;绝对&amp;quot;了。从 JDK 7 开始，Java 虚拟机已经默认开启逃逸分析了，意味着如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。&lt;strong&gt;垃圾指 JVM 中没有任何引用指向它的对象&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;逃逸分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逃逸分析&lt;/strong&gt;是一种编译器优化技术，用于判断对象的作用域和生命周期。如果编译器确定一个对象不会逃逸出方法或线程的范围，它可以选择在栈上分配这个对象，而不是在堆上。这样做可以减少垃圾回收的压力，并提高性能。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一个 JVM 实例只有一个堆内存&lt;/strong&gt;，堆内存大小可以调节，类加载器读取类文件后要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，堆内存在逻辑上分为三部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;新生代：伊甸区、幸存 0 区 from、幸存 1 区 to&lt;/li&gt;
&lt;li&gt;老年代&lt;/li&gt;
&lt;li&gt;永久代&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-9.png&#34;
	width=&#34;1537&#34;
	height=&#34;961&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-9_hu_f66a773384698531.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-9_hu_76cd65d480e9f80e.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;159&#34;
		data-flex-basis=&#34;383px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-10.png&#34;
	width=&#34;948&#34;
	height=&#34;483&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-10_hu_48b9b69e86cc172b.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-10_hu_b01a40f3889d0644.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;196&#34;
		data-flex-basis=&#34;471px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;43-执行引擎&#34;&gt;&lt;a href=&#34;#43-%e6%89%a7%e8%a1%8c%e5%bc%95%e6%93%8e&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;4.3 执行引擎
&lt;/h3&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h2 id=&#34;双亲委派&#34;&gt;&lt;a href=&#34;#%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;双亲委派
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;应用程序类加载器（又叫系统类加载器）收到类的加载请求先检查自己是否加载过该类，如果没有，将请求向上委托给自己的父类加载器（extensionLoader），如果父类加载器也没有加载过该类，该父类加载器继续向上委托给自己的父类加载器（bootstrapLoader，又叫根加载器、启动类加载器）若启动类加载器也没有加载过该类，则会根据要加载的类的全限定名尝试加载该类，若加载成功，则返回引用，若加载失败，则抛出异常，并反向委托给扩展类加载器，若仍加载失败，则继续抛出异常，并反向委托给应用程序类加载器，若仍加载失败，则报异常 ClassNotFound。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-11.png&#34;
	width=&#34;773&#34;
	height=&#34;410&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-11_hu_1e5989d47a93a02c.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-11_hu_9e9b299909408c00.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;188&#34;
		data-flex-basis=&#34;452px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-12.png&#34;
	width=&#34;1353&#34;
	height=&#34;1043&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-12_hu_6d615e96fabdd3cb.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-12_hu_ceebc7a29d5729b7.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;129&#34;
		data-flex-basis=&#34;311px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-13.png&#34;
	width=&#34;1715&#34;
	height=&#34;1083&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-13_hu_4ad54ac5bb2aa1c4.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-13_hu_d6ed6094810b4de4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;158&#34;
		data-flex-basis=&#34;380px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;安全性和沙箱机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于 java 核心库和扩展库由根加载器加载，这些库中的类有更高的安全级别，而应用程序类由应用程序类加载器加载，安全级别低，双亲向上委派可以防止核心 API 被篡改，提高了程序安全性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是沙箱？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java 安全模型的核心就是 java 沙箱，沙箱是一个限制程序运行的环境，沙箱机制就是把 java 代码限定在 jvm 的特定运行范围内，严格限制代码对本地系统资源的访问（CPU、内存、文件系统、网络等），通过这样来保证代码的有效隔离，防止对本地系统造成破坏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;避免类重复加载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于父类加载器加载类时会优先尝试加载，若类已经被加载过，就不会再次加载，避免了类重复加载。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;破坏双亲委派&#34;&gt;&lt;a href=&#34;#%e7%a0%b4%e5%9d%8f%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;破坏双亲委派
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;打破双亲委派机制历史上有三种方式，但本质上只有&lt;strong&gt;第一种&lt;/strong&gt;算是真正的打破了双亲委派机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;自定义类加载器并且重写 loadClass 方法。Tomcat 通过这种方式实现应用之间类隔离。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程上下文类加载器。利用上下文类加载器加载类，比如 JDBC 和 JNDI 等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Osgi 框架的类加载器。历史上 Osgi 框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载，目前很少使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;tomcat-破坏&#34;&gt;&lt;a href=&#34;#tomcat-%e7%a0%b4%e5%9d%8f&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Tomcat 破坏
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-14.png&#34;
	width=&#34;1515&#34;
	height=&#34;888&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-14_hu_4d457dbd687a5c03.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-14_hu_380b01ab93371d16.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;170&#34;
		data-flex-basis=&#34;409px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;jdbc-破坏&#34;&gt;&lt;a href=&#34;#jdbc-%e7%a0%b4%e5%9d%8f&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;JDBC 破坏
&lt;/h4&gt;&lt;p&gt;JDBC 中使用了 DriverManager 来管理项目中引入的不同数据库的驱动，比如 mysql 驱动、oracle 驱动。DriverManager 类位于 rt.jar 包中，由启动类加载器加载。依赖中的 mysql 驱动对应的类，由应用程序类加载器来加载。DriverManager 属于 rt.jar 是启动类加载器加载的。而用户 jar 包中的驱动需要由应用类加载器加载，_这就违反了双亲委派机制 。&lt;strong&gt;存疑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-15.png&#34;
	width=&#34;999&#34;
	height=&#34;456&#34;
	srcset=&#34;/zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-15_hu_3ec93d7c7fb45c8.png 480w, /zh-cn/post/2025/02/jvm%E5%9B%BE%E6%96%87%E5%85%A5%E9%97%A8/image-15_hu_2631586bb1247648.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;219&#34;
		data-flex-basis=&#34;525px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JDBC 案例中真的打破了双亲委派机制吗?&lt;/p&gt;
&lt;p&gt;最早这个论点提出是在周志明《深入理解 Java 虚拟机》中，他认为打破了双亲委派机制，这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，所以打破了双亲委派机制。&lt;/p&gt;
&lt;p&gt;但是如果我们分别从 DriverManager 以及驱动类的加载流程上分析，JDBC 只是在 DriverManager 加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依然遵循双亲委派机制。&lt;/p&gt;
&lt;p&gt;所以我认为这里没有打破双亲委派机制，只是用一种巧妙的方法让启动类加载器加载的类，去引发的其他类的加载。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>String.intern()</title>
        <link>/zh-cn/post/2024/12/string.intern/</link>
        <pubDate>Mon, 30 Dec 2024 12:00:00 +0000</pubDate>
        
        <guid>/zh-cn/post/2024/12/string.intern/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;String.intern()&lt;/code&gt; 是一个 &lt;code&gt;native&lt;/code&gt; (本地) 方法，用来处理字符串常量池中的字符串对象引用。它的工作流程可以概括为以下两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;常量池中已有相同内容的字符串对象&lt;/strong&gt; ：如果字符串常量池中已经有一个与调用 &lt;code&gt;intern()&lt;/code&gt; 方法的字符串内容相同的 &lt;code&gt;String&lt;/code&gt; 对象，&lt;code&gt;intern()&lt;/code&gt; 方法会直接返回常量池中该对象的引用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常量池中没有相同内容的字符串对象&lt;/strong&gt; ：如果字符串常量池中还没有一个与调用 &lt;code&gt;intern()&lt;/code&gt; 方法的字符串内容相同的对象，&lt;code&gt;intern()&lt;/code&gt; 方法会将当前字符串对象的引用添加到字符串常量池中，并返回该引用。
&lt;strong&gt;总结&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;intern()&lt;/code&gt; 方法的主要作用是&lt;strong&gt;确保字符串引用在常量池中的唯一性。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当调用 &lt;code&gt;intern()&lt;/code&gt; 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// s1 指向字符串常量池中的 &amp;#34;Java&amp;#34; 对象&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Java&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// s2 也指向字符串常量池中的 &amp;#34;Java&amp;#34; 对象，和 s1 是同一个对象&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;intern&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 在堆中创建一个新的 &amp;#34;Java&amp;#34; 对象，s3 指向它&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Java&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// s4 指向字符串常量池中的 &amp;#34;Java&amp;#34; 对象，和 s1 是同一个对象&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;intern&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// s1 和 s2 指向的是同一个常量池中的对象&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// s3 指向堆中的对象，s4 指向常量池中的对象，所以不同&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// s1 和 s4 都指向常量池中的同一个对象&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        
    </channel>
</rss>
