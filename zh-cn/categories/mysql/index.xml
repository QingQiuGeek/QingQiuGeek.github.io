<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>MySQL on 青秋博客</title>
        <link>/zh-cn/categories/mysql/</link>
        <description>Recent content in MySQL on 青秋博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>青秋博客</copyright>
        <lastBuildDate>Sat, 06 Sep 2025 12:39:19 +0000</lastBuildDate><atom:link href="/zh-cn/categories/mysql/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>MySQL锁</title>
        <link>/zh-cn/post/2025/09/mysql%E9%94%81/</link>
        <pubDate>Sat, 06 Sep 2025 12:39:19 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/09/mysql%E9%94%81/</guid>
        <description>&lt;h2 id=&#34;1全局锁&#34;&gt;&lt;a href=&#34;#1%e5%85%a8%e5%b1%80%e9%94%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;1.全局锁
&lt;/h2&gt;&lt;blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;加全局锁&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flush&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;with&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;释放全局锁&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;执行后，**整个数据库就处于只读状态，加上了全局锁。**全局锁颗粒度比表级锁大，此时所有线程对表结构、表数据只能执行读了。&lt;/p&gt;
&lt;p&gt;当然，如果当前加全局锁的会话断开，全局锁会被自动释放。&lt;/p&gt;
&lt;p&gt;全局锁主要用于全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新&lt;br&gt;
而出现备份文件的数据与预期的不一样。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;2表级锁&#34;&gt;&lt;a href=&#34;#2%e8%a1%a8%e7%ba%a7%e9%94%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;2.表级锁
&lt;/h2&gt;&lt;h3 id=&#34;21-表锁&#34;&gt;&lt;a href=&#34;#21-%e8%a1%a8%e9%94%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;2.1 表锁
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;//表级别的共享锁，也就是读锁；&lt;br&gt;
//允许当前会话读表，阻止其他会话写表。&lt;strong&gt;同时本会话不能访问其他表&lt;/strong&gt;。&lt;br&gt;
lock tables student read;&lt;/p&gt;
&lt;p&gt;//表级别的独占锁，也就是写锁；&lt;br&gt;
//允许当前会话对表进行读写操作，阻止其他会话对表进行任何操作（读或写）。&lt;br&gt;
lock tables student write;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;22-意向锁&#34;&gt;&lt;a href=&#34;#22-%e6%84%8f%e5%90%91%e9%94%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;2.2 意向锁
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;当要使用表锁时，&lt;strong&gt;如何判断表中的记录没有行锁呢&lt;/strong&gt;，一行一行遍历肯定是不行，性能太差。&lt;strong&gt;要用意向锁&lt;/strong&gt;来快速判断是否可以对某个表使用表锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;意向共享锁（Intention Shared Lock，IS 锁）&lt;/strong&gt;：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;意向排他锁（Intention Exclusive Lock，IX 锁）&lt;/strong&gt;：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;意向锁之间兼容，与行级的共享锁和排他锁兼容，但是和表级的共享锁和排他锁互斥。&lt;/strong&gt;&lt;br&gt;
所以说当执行增、删、改操作，需要&lt;strong&gt;先对表加上「意向独占锁」&lt;/strong&gt;，然后对该记录加独占锁。&lt;/p&gt;
&lt;p&gt;另外当前读的 select 也会加共享锁、独占锁。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;3行锁&#34;&gt;&lt;a href=&#34;#3%e8%a1%8c%e9%94%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;3.行锁
&lt;/h2&gt;&lt;h3 id=&#34;31-间隙锁&#34;&gt;&lt;a href=&#34;#31-%e9%97%b4%e9%9a%99%e9%94%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;3.1 间隙锁
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;间隙锁是一种加在两个索引之间的锁，锁的是一个&lt;strong&gt;开区间&lt;/strong&gt;，&lt;strong&gt;只存在于可重复读隔离级别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设，表中有一个范围 id 为(3,5]的 next-key lock，那么其他事务即不能插入 id=4 记录，也不能修改 id=5 这条记录。
&lt;img src=&#34;/zh-cn/post/2025/09/mysql%E9%94%81/image.png&#34;
	width=&#34;411&#34;
	height=&#34;231&#34;
	srcset=&#34;/zh-cn/post/2025/09/mysql%E9%94%81/image_hu_a9d08927f74782d.png 480w, /zh-cn/post/2025/09/mysql%E9%94%81/image_hu_f36a6ee9e77d423e.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;427px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;临建锁和间隙锁在幻读中的使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Terry-Wu/p/12219019.html&#34;  title=&#34;详解 MySql InnoDB 中的三种行锁（记录锁、间隙锁与临键锁） - HappyDeveloper - 博客园&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;详解 MySql InnoDB 中的三种行锁（记录锁、间隙锁与临键锁） - HappyDeveloper - 博客园&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用间隙锁的情况&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非唯一索引的等值查询&lt;/strong&gt;：例如&lt;code&gt;SELECT * FROM table WHERE non_unique_col = 5 FOR UPDATE&lt;/code&gt;，若&lt;code&gt;5&lt;/code&gt;存在，会锁定&lt;code&gt;5&lt;/code&gt;周围的间隙；若&lt;code&gt;5&lt;/code&gt;不存在，则锁定其应存在的间隙。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;范围查询&lt;/strong&gt;：如&lt;code&gt;WHERE id &amp;gt; 10&lt;/code&gt;，若未命中记录，会锁定符合条件的间隙。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;唯一索引的等值查询（未命中）&lt;/strong&gt;：如&lt;code&gt;SELECT * FROM table WHERE unique_col = 15 FOR UPDATE&lt;/code&gt;，当&lt;code&gt;15&lt;/code&gt;不存在时，锁定其所在的间隙。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;临键锁触发条件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非唯一索引的范围查询&lt;/strong&gt;：如&lt;code&gt;WHERE non_unique_col BETWEEN 5 AND 10&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;唯一索引的范围查询&lt;/strong&gt;：如&lt;code&gt;WHERE unique_col &amp;gt; 10&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;默认锁机制&lt;/strong&gt;：在可重复读级别下，InnoDB 默认对索引扫描使用临键锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;32-记录锁&#34;&gt;&lt;a href=&#34;#32-%e8%ae%b0%e5%bd%95%e9%94%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;3.2 记录锁
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;记录锁是最简单的行锁，仅锁住一行，有读锁和写锁之分，读写锁互斥。&lt;/p&gt;
&lt;p&gt;如：&lt;code&gt;SELECT c1 FROM t WHERE c1 = 10 **FOR UPDATE**&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果 C1 字段是主键或者是唯一索引的话，这个 SQL 会加一个记录锁，&lt;strong&gt;记录锁永远都是加在索引上的，即使一个表没有索引，InnoDB 也会隐式的创建一个索引&lt;/strong&gt;，并使用这个索引实施记录锁。它会阻塞其他事务对这行记录的插入、更新、删除。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;33-临键锁&#34;&gt;&lt;a href=&#34;#33-%e4%b8%b4%e9%94%ae%e9%94%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;3.3 临键锁
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Next-key 锁是&lt;strong&gt;记录锁和间隙锁的组合&lt;/strong&gt;，&lt;strong&gt;解决了锁定读的幻读问题（非锁定读用快照读即可解决幻读）&lt;/strong&gt;，它指的是加在某条记录以及这条记录前面间隙上的锁。说得更具体一点就是:临键锁会封锁索引记录本身，以及索引记录之前的区间，即&lt;strong&gt;它的锁区间是左开右闭&lt;/strong&gt;，比如 (&lt;code&gt;5,10]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 InnoDB 默认的隔离级别 可重复读 下，行锁默认使用的是临键锁。但是，如果操作的索引是唯一索引或主键，InnoDB 会对临键锁进行优化，将其降级为 记录锁 ，即仅锁住索引本身，而不是范围。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;34-自增锁表级锁&#34;&gt;&lt;a href=&#34;#34-%e8%87%aa%e5%a2%9e%e9%94%81%e8%a1%a8%e7%ba%a7%e9%94%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;3.4 自增锁（表级锁）
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;专门针对**&lt;code&gt;AUTO_INCREMENT&lt;/code&gt;&lt;strong&gt;类型的列，对于这种列，如果表中新增数据时就会去持有自增锁。简言之，如果一个事务正在往表中插入记录，所有&lt;/strong&gt;其他事务的插入必须等待**，以便第一个事务插入的行，是&lt;strong&gt;连续的主键值。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;35-插入意向锁&#34;&gt;&lt;a href=&#34;#35-%e6%8f%92%e5%85%a5%e6%84%8f%e5%90%91%e9%94%81&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;&lt;strong&gt;3.5 插入意向锁&lt;/strong&gt;
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。&lt;/p&gt;
&lt;p&gt;当事务 A 还没提交的时候，事务 B 向该表插入一条 id=4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态(PS:MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了唢，此时事务 B 就会发生阻塞，直到事务 A 提交了事务。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;行级锁和表级锁对比&#34;&gt;&lt;a href=&#34;#%e8%a1%8c%e7%ba%a7%e9%94%81%e5%92%8c%e8%a1%a8%e7%ba%a7%e9%94%81%e5%af%b9%e6%af%94&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;行级锁和表级锁对比
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;表级锁：&lt;/strong&gt; MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发&lt;strong&gt;锁冲突的概率最高&lt;/strong&gt;，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;行级锁：&lt;/strong&gt; MySQL 中锁定粒度最小的一种锁，是 &lt;strong&gt;针对索引字段加的锁&lt;/strong&gt; ，只针对当前操作的行记录进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。&lt;/li&gt;
&lt;li&gt;InnoDB 的行锁是&lt;strong&gt;针对索引字段加的锁&lt;/strong&gt;，&lt;strong&gt;表级锁是针对非索引字段加的锁&lt;/strong&gt;。当我们执行 &lt;code&gt;UPDATE&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt; 语句时，如果 &lt;code&gt;WHERE&lt;/code&gt;条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>mysql深度分页</title>
        <link>/zh-cn/post/2025/09/mysql%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5/</link>
        <pubDate>Fri, 05 Sep 2025 12:39:19 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/09/mysql%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5/</guid>
        <description>&lt;h2 id=&#34;概念&#34;&gt;&lt;a href=&#34;#%e6%a6%82%e5%bf%b5&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;概念
&lt;/h2&gt;&lt;p&gt;当使用 limit 查询偏移量过大时（limit 通常用来分页），导致回表次数变多、走全表不利用索引，然后导致查询性能变低。&lt;/p&gt;
&lt;p&gt;如：SELECT * FROM t_order LIMIT 1000000, 10&lt;/p&gt;
&lt;p&gt;会扫描并取 1000000+10 行，然后放弃前 1000000 行，返回 10 行。
高并发下容易造成 CPU、IO、内存暴涨，甚至 OOM。
不过，即使偏移量很大，如果查询中使用了覆盖索引，MySQL 仍然可能会使用索引，避免回表操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话总结：&lt;strong&gt;“深分页不用 OFFSET，用条件(where)定位起点”&lt;/strong&gt; 是所有优化手段的核心,从而避免大偏移量带来的全表扫描和大量回表。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;游标范围分页推荐&#34;&gt;&lt;a href=&#34;#%e6%b8%b8%e6%a0%87%e8%8c%83%e5%9b%b4%e5%88%86%e9%a1%b5%e6%8e%a8%e8%8d%90&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;游标/范围分页（推荐）
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;：记住上一页&lt;strong&gt;最后一条记录的主键（或排序列）&lt;/strong&gt;，作为下一页的起始条件。&lt;br&gt;
&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 上一页最后一条 id = 100000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t_order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;-- 无 OFFSET
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ORDER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LIMIT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;优点：直接跳到 100000，性能稳定，不随页码增大而衰减；千万级数据仍可毫秒级返回。&lt;/li&gt;
&lt;li&gt;缺点：只能&lt;strong&gt;顺序翻页&lt;/strong&gt;，不能随机跳页；需要排序列唯一且连续。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;延迟关联join-子查询&#34;&gt;&lt;a href=&#34;#%e5%bb%b6%e8%bf%9f%e5%85%b3%e8%81%94join-%e5%ad%90%e6%9f%a5%e8%af%a2&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;  延迟关联（JOIN 子查询）
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;：&lt;strong&gt;先用覆盖索引在子查询里拿到主键&lt;/strong&gt;，再回表取完整行，减少大 OFFSET 的回表量。&lt;br&gt;
&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t_order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;JOIN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t_order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;create_time&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;2023-01-01&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ORDER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;create_time&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LIMIT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4500000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ON&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;优点：比直接 &lt;code&gt;LIMIT 4500000,10&lt;/code&gt; （该方法先数 4500000 条数据，然后丢掉，）少读 450w 行数据。&lt;/li&gt;
&lt;li&gt;注意：子查询里的列必须被索引覆盖，否则仍可能全表扫描。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;覆盖索引--子查询定位起点&#34;&gt;&lt;a href=&#34;#%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95--%e5%ad%90%e6%9f%a5%e8%af%a2%e5%ae%9a%e4%bd%8d%e8%b5%b7%e7%82%b9&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;覆盖索引 + 子查询定位起点
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;：先用覆盖索引查出第 N 条记录的排序列值，再用该值作为条件取后 10 条。&lt;br&gt;
&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 1. 查出第 4500000 行的 create_time
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;create_time&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t_order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ORDER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;create_time&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LIMIT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4500000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;-- 2. 用该 create_time 作为起点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t_order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;create_time&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;上一步的值&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ORDER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;create_time&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LIMIT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;优点：避免大 OFFSET；支持非主键排序。&lt;/li&gt;
&lt;li&gt;注意：排序列必须有索引，否则第 1 步也会很慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;预计算或缓存&#34;&gt;&lt;a href=&#34;#%e9%a2%84%e8%ae%a1%e7%ae%97%e6%88%96%e7%bc%93%e5%ad%98&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;预计算或缓存
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态数据&lt;/strong&gt;可提前算好页码结果，放入 Redis 或 ES，彻底避开 MySQL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态数据&lt;/strong&gt;可用异步任务把每页首条主键写入缓存，查询时直接 &lt;code&gt;&amp;gt;&lt;/code&gt; 条件。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>联合索引abc，请问查询哪些字段能命中索引</title>
        <link>/zh-cn/post/2025/09/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95abc%E8%AF%B7%E9%97%AE%E6%9F%A5%E8%AF%A2%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%E8%83%BD%E5%91%BD%E4%B8%AD%E7%B4%A2%E5%BC%95/</link>
        <pubDate>Fri, 05 Sep 2025 12:39:19 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/09/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95abc%E8%AF%B7%E9%97%AE%E6%9F%A5%E8%AF%A2%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%E8%83%BD%E5%91%BD%E4%B8%AD%E7%B4%A2%E5%BC%95/</guid>
        <description>&lt;p&gt;查询语句：select * from table where a=? and b&amp;gt; ? and c=?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字段&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;能命中索引，&lt;code&gt;c&lt;/code&gt;无法命中索引&lt;/strong&gt;,但是字段&lt;code&gt;c&lt;/code&gt;的条件可以通过 “索引下推”过滤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;联合索引&lt;code&gt;(a, b, c)&lt;/code&gt;的结构决定了先匹配&lt;code&gt;a&lt;/code&gt;，再匹配&lt;code&gt;b&lt;/code&gt;，最后是&lt;code&gt;c&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;b&lt;/code&gt;使用了范围查询（&lt;code&gt;b&amp;gt; ?&lt;/code&gt;），范围查询会&lt;strong&gt;中断索引&lt;/strong&gt;的进一步使用。也就是说，一旦遇到范围查询，索引只能用到该字段为止。因此&lt;code&gt;b&lt;/code&gt; 会命中索引，但索引的使用会在这里中断。&lt;code&gt;c&lt;/code&gt;无法直接使用索引进行匹配。&lt;/li&gt;
&lt;li&gt;但开启&lt;strong&gt;索引下推&lt;/strong&gt;后，在存储引擎在遍历索引时，会同时检查&lt;code&gt;c=？&lt;/code&gt;的条件，直接过滤掉不满足&lt;code&gt;c=？&lt;/code&gt;的记录，最后把数据返回给 Server 层，而无需将这些记录回表查询完整数据后再过滤。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然&lt;code&gt;c&lt;/code&gt;不参与索引的范围定位，但通过索引下推，&lt;code&gt;c=？&lt;/code&gt;的条件会在存储引擎的索引层面被提前过滤，减少了回表的记录数，提高查询效率。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>MySQL表分区</title>
        <link>/zh-cn/post/2025/09/mysql%E8%A1%A8%E5%88%86%E5%8C%BA/</link>
        <pubDate>Fri, 05 Sep 2025 10:39:19 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/09/mysql%E8%A1%A8%E5%88%86%E5%8C%BA/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;表分区是将表中的数据按照某种规则（如范围、列表、哈希等）分散存储到多个分区中。每个分区可以独立地进行操作，例如查询、插入、更新和删除。分区的目的是将数据分散到多个存储单元中，从而提高性能和可管理性。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;分区的类型&#34;&gt;&lt;a href=&#34;#%e5%88%86%e5%8c%ba%e7%9a%84%e7%b1%bb%e5%9e%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;分区的类型
&lt;/h2&gt;&lt;h3 id=&#34;范围分区range&#34;&gt;&lt;a href=&#34;#%e8%8c%83%e5%9b%b4%e5%88%86%e5%8c%barange&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;范围分区（RANGE）
&lt;/h3&gt;&lt;p&gt;根据字段值的范围将数据分配到不同的分区。适用于连续的数值或日期范围。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;CREATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sales&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;INT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sale_date&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;DATE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;amount&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;DECIMAL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RANGE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;YEAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sale_date&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2022&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2023&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2023&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2024&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2024&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2025&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;列表分区list&#34;&gt;&lt;a href=&#34;#%e5%88%97%e8%a1%a8%e5%88%86%e5%8c%balist&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;列表分区（LIST）
&lt;/h3&gt;&lt;p&gt;根据字段值的列表将数据分配到不同的分区。适用于离散的值集合。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;CREATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;employees&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;INT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;department_id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;INT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;VARCHAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;50&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LIST&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;department_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p_sales&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;IN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p_marketing&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;IN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p_it&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;IN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;哈希分区hash&#34;&gt;&lt;a href=&#34;#%e5%93%88%e5%b8%8c%e5%88%86%e5%8c%bahash&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;哈希分区（HASH）
&lt;/h3&gt;&lt;p&gt;根据字段值的哈希值将数据分配到不同的分区。适用于均匀分布数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;CREATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;users&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;INT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;username&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;VARCHAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;50&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HASH&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITIONS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;键分区key&#34;&gt;&lt;a href=&#34;#%e9%94%ae%e5%88%86%e5%8c%bakey&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;键分区（KEY）
&lt;/h3&gt;&lt;p&gt;类似于哈希分区，但使用 MySQL 的内部哈希函数。适用于主键或唯一键的分区。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;CREATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;orders&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;order_id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;INT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;PRIMARY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;KEY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;customer_id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;INT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;order_date&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;DATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;KEY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;order_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITIONS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;分区的优势&#34;&gt;&lt;a href=&#34;#%e5%88%86%e5%8c%ba%e7%9a%84%e4%bc%98%e5%8a%bf&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;分区的优势
&lt;/h2&gt;&lt;h3 id=&#34;提高查询性能&#34;&gt;&lt;a href=&#34;#%e6%8f%90%e9%ab%98%e6%9f%a5%e8%af%a2%e6%80%a7%e8%83%bd&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;提高查询性能
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;减少扫描范围&lt;/strong&gt;：查询时，MySQL 只需要扫描相关的分区，而不是整个表，从而减少 I/O 操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并行查询&lt;/strong&gt;：在某些情况下，MySQL 可以并行处理分区查询，进一步提高性能。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;简化数据维护&#34;&gt;&lt;a href=&#34;#%e7%ae%80%e5%8c%96%e6%95%b0%e6%8d%ae%e7%bb%b4%e6%8a%a4&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;简化数据维护
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据清理&lt;/strong&gt;：可以通过删除分区来快速清理旧数据，而不需要逐条删除记录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据备份&lt;/strong&gt;：可以单独备份或恢复某些分区，而不是整个表。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;优化存储管理&#34;&gt;&lt;a href=&#34;#%e4%bc%98%e5%8c%96%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;优化存储管理
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分散存储&lt;/strong&gt;：可以将不同的分区存储在不同的物理设备上，从而优化存储性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表空间管理&lt;/strong&gt;：可以为每个分区指定不同的表空间，便于管理存储空间。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;分区的限制&#34;&gt;&lt;a href=&#34;#%e5%88%86%e5%8c%ba%e7%9a%84%e9%99%90%e5%88%b6&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;分区的限制
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分区键必须是表的主键或唯一键的一部分&lt;/strong&gt;：如果表有主键或唯一键，分区键必须是这些键的一部分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分区键不能包含外键&lt;/strong&gt;：外键不能作为分区键。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分区键必须是数值或日期类型&lt;/strong&gt;：分区键必须是数值或日期类型，不能是字符串类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分区数量有限制&lt;/strong&gt;：MySQL 对分区数量有限制，通常是 1024 个分区。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;分区的维护&#34;&gt;&lt;a href=&#34;#%e5%88%86%e5%8c%ba%e7%9a%84%e7%bb%b4%e6%8a%a4&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;分区的维护
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;添加分区&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;ALTER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sales&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ADD&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2025&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2026&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;删除分区&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;ALTER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sales&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;DROP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2022&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;合并分区&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;ALTER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sales&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MERGE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITIONS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2022&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2023&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;INTO&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2022_2023&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重新组织分区&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;ALTER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sales&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;REORGANIZE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2022&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2023&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;INTO&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2022_2023&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2024&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;示例范围分区&#34;&gt;&lt;a href=&#34;#%e7%a4%ba%e4%be%8b%e8%8c%83%e5%9b%b4%e5%88%86%e5%8c%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;  示例：范围分区
&lt;/h2&gt;&lt;p&gt;假设有一个 &lt;code&gt;sales&lt;/code&gt; 表，记录了每年的销售数据。我们可以按年进行范围分区：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;CREATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sales&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;INT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;PRIMARY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;KEY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sale_date&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;DATE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;amount&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;DECIMAL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RANGE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;YEAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sale_date&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2022&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2023&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2023&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2024&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2024&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2025&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h5 id=&#34;插入数据&#34;&gt;&lt;a href=&#34;#%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;插入数据
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;INSERT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;INTO&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sales&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sale_date&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;amount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;2022-01-01&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;00&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;INSERT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;INTO&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sales&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sale_date&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;amount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;2023-01-01&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;00&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;INSERT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;INTO&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sales&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sale_date&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;amount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;2024-01-01&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;300&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;00&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h5 id=&#34;查询数据&#34;&gt;&lt;a href=&#34;#%e6%9f%a5%e8%af%a2%e6%95%b0%e6%8d%ae&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;查询数据
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sales&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sale_date&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BETWEEN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;2023-01-01&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;AND&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;2023-12-31&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;这个查询只会扫描 &lt;code&gt;p2023&lt;/code&gt; 分区，而不是整个表。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>如何保证redis和mysql的数据一致性</title>
        <link>/zh-cn/post/2025/09/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81redis%E5%92%8Cmysql%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</link>
        <pubDate>Wed, 03 Sep 2025 12:39:19 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/09/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81redis%E5%92%8Cmysql%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;参考:&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/xiaolincoding/p/16493675.html&#34;  title=&#34;面试官：3 种缓存更新策略是怎样的？ - 小林coding - 博客园&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;面试官：3 种缓存更新策略是怎样的？ - 小林 coding - 博客园&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.nowcoder.com/discuss/766955367430438912?sourceSSR=users&#34;  title=&#34;腾讯二面：Redis与MySQL一致性如何保证？_牛客网&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;腾讯二面：Redis 与 MySQL 一致性如何保证？_牛客网&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;旁路缓存模式cache-aside-pattern&#34;&gt;&lt;a href=&#34;#%e6%97%81%e8%b7%af%e7%bc%93%e5%ad%98%e6%a8%a1%e5%bc%8fcache-aside-pattern&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;旁路缓存模式（Cache Aside Pattern）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;适合读多写少的场景，因为当写入比较频繁时，&lt;strong&gt;缓存会被频繁删除&lt;/strong&gt;，对缓存的命中率有影响。&lt;br&gt;
读时先读 redis，读不到则查 mysql，写时先更新 mysql，然后删除 redis 缓存。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;而上述成功的前提这两个操作都能同时执行成功，所以问题就是，在删除缓存（第二个操作）的时候失败了，导致缓存中的数据是旧值，而数据库是最新值。如何保证两个操作都能执行成功？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;消息队列重试机制&lt;br&gt;
消息队列来重试缓存的删除，优点是保证缓存一致性的问题，缺点会对业务代码入侵&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;订阅 MySQL binlog，再操作缓存&lt;/p&gt;
&lt;p&gt;订阅 MySQL binlog + 消息队列 + 重试缓存的删除，优点是规避了代码入侵问题，也很好的保证缓存一致性的问题，缺点就是引入的组件比较多。&lt;br&gt;
做法：将 binlog 日志采集发送到 MQ 队列里面，然后编写一个简单的缓存删除消息者订阅 binlog 日志，根据更新 log 删除缓存，并且通过 ACK 机制确认处理这条更新 log，保证数据缓存一致性。&lt;br&gt;
这两种方法有一个共同的特点，都是采用异步操作缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;异步更新write-behind&#34;&gt;&lt;a href=&#34;#%e5%bc%82%e6%ad%a5%e6%9b%b4%e6%96%b0write-behind&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;异步更新（Write Behind）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;实时性&lt;/strong&gt;要求较高的场景中，可以先更新 Redis 缓存，然后再异步更新 MySQL 数据库。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;双写操作write-through&#34;&gt;&lt;a href=&#34;#%e5%8f%8c%e5%86%99%e6%93%8d%e4%bd%9cwrite-through&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;双写操作（Write Through）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在某些业务场景中，需要同时更新 Redis 和 MySQL 的数据。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;延迟回写write-back&#34;&gt;&lt;a href=&#34;#%e5%bb%b6%e8%bf%9f%e5%9b%9e%e5%86%99write-back&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;  延迟回写（Write Back）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Redis 中数据更新后并不立即同步更新 MySQL，而是在特定时机触发数据&lt;strong&gt;批量&lt;/strong&gt;回写。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>MYSQL表结构优化场景</title>
        <link>/zh-cn/post/2025/09/mysql%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96%E5%9C%BA%E6%99%AF/</link>
        <pubDate>Mon, 01 Sep 2025 15:41:13 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/09/mysql%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96%E5%9C%BA%E6%99%AF/</guid>
        <description>&lt;h2 id=&#34;合理设计表字段类型&#34;&gt;&lt;a href=&#34;#%e5%90%88%e7%90%86%e8%ae%be%e8%ae%a1%e8%a1%a8%e5%ad%97%e6%ae%b5%e7%b1%bb%e5%9e%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;合理设计表字段类型
&lt;/h2&gt;&lt;p&gt;根据字段的实际用途选择最合适的数据类型。例如 char、varchar()、int、bigint，&lt;strong&gt;datetime 还是 timestamp&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建合适的索引&#34;&gt;&lt;a href=&#34;#%e5%88%9b%e5%bb%ba%e5%90%88%e9%80%82%e7%9a%84%e7%b4%a2%e5%bc%95&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;创建合适的索引
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主键索引&lt;/strong&gt;：每个表都应该有一个主键，主键字段通常是唯一的且不可为空。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;唯一索引&lt;/strong&gt;：如果某个字段的值必须唯一，可以为其创建唯一索引。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;普通索引&lt;/strong&gt;：为经常用于查询条件的字段创建普通索引，可以提高查询效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复合索引&lt;/strong&gt;：如果查询条件涉及多个字段，可以创建复合索引。例如，对于查询条件 &lt;code&gt;WHERE a = ? AND b = ?&lt;/code&gt;，可以创建复合索引 &lt;code&gt;(a, b)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;表分区&#34;&gt;&lt;a href=&#34;#%e8%a1%a8%e5%88%86%e5%8c%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;表分区
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;水平分区&lt;/strong&gt;：将表中的数据按行分割到多个分区中，可以提高查询效率，尤其是在处理大量数据时。例如，可以根据日期或用户 ID 进行分区。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;垂直分区&lt;/strong&gt;：将表中的字段按列分割到多个表中，可以减少表的宽度，提高查询效率。例如，将不常用的字段移到单独的表中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;归一化与反归一化&#34;&gt;&lt;a href=&#34;#%e5%bd%92%e4%b8%80%e5%8c%96%e4%b8%8e%e5%8f%8d%e5%bd%92%e4%b8%80%e5%8c%96&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;  归一化与反归一化
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;归一化（范式）&lt;/strong&gt;：将数据分解到多个表中，减少数据冗余，提高数据一致性。例如，将用户信息和订单信息分别存储在不同的表中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反归一化（反范式）&lt;/strong&gt;：在某些情况下，为了提高查询效率，可以适当冗余一些数据。例如，在订单表中冗余用户的基本信息，减少表连接操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##  合理使用外键&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;外键约束&lt;/strong&gt;：外键可以确保数据的完整性，但在某些情况下可能会降低性能。如果性能是首要考虑因素，可以考虑在应用层实现数据完整性约束。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外键的维护成本&lt;/strong&gt;：外键会增加插入、更新和删除操作的开销，尤其是在表数据量较大时。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;优化表的存储引擎&#34;&gt;&lt;a href=&#34;#%e4%bc%98%e5%8c%96%e8%a1%a8%e7%9a%84%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;优化表的存储引擎
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;InnoDB&lt;/strong&gt;：支持事务、行级锁和外键，适合需要高并发和事务支持的场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MyISAM&lt;/strong&gt;：不支持事务，但查询速度较快，适合读多写少的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分表分库&#34;&gt;&lt;a href=&#34;#%e5%88%86%e8%a1%a8%e5%88%86%e5%ba%93&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;分表分库
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分表&lt;/strong&gt;：当表的数据量过大时，可以将表拆分成多个子表，每个子表存储部分数据。例如，按日期或用户 ID 分表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分库&lt;/strong&gt;：将不同的业务数据存储在不同的数据库中，可以减少单个数据库的压力，提高系统的可扩展性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;监控和分析&#34;&gt;&lt;a href=&#34;#%e7%9b%91%e6%8e%a7%e5%92%8c%e5%88%86%e6%9e%90&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;监控和分析
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;性能监控&lt;/strong&gt;：使用 MySQL 的性能监控工具（如 &lt;code&gt;SHOW STATUS&lt;/code&gt;、&lt;code&gt;SHOW GLOBAL STATUS&lt;/code&gt;）监控数据库的性能指标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;慢查询日志&lt;/strong&gt;：启用慢查询日志，记录执行时间较长的查询语句，分析并优化这些查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;示例优化一个用户表&#34;&gt;&lt;a href=&#34;#%e7%a4%ba%e4%be%8b%e4%bc%98%e5%8c%96%e4%b8%80%e4%b8%aa%e7%94%a8%e6%88%b7%e8%a1%a8&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;示例：优化一个用户表
&lt;/h2&gt;&lt;p&gt;假设有一个用户表 &lt;code&gt;users&lt;/code&gt;，包含以下字段：&lt;/p&gt;
&lt;h3 id=&#34;优化前的表结构&#34;&gt;&lt;a href=&#34;#%e4%bc%98%e5%8c%96%e5%89%8d%e7%9a%84%e8%a1%a8%e7%bb%93%e6%9e%84&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;&lt;strong&gt;优化前的表结构&lt;/strong&gt;
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;CREATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;users&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;INT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;PRIMARY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;KEY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;username&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;VARCHAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NOT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;email&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;VARCHAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NOT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;created_at&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DATETIME&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NOT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;last_login&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DATETIME&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;优化后的表结构&#34;&gt;&lt;a href=&#34;#%e4%bc%98%e5%8c%96%e5%90%8e%e7%9a%84%e8%a1%a8%e7%bb%93%e6%9e%84&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;&lt;strong&gt;优化后的表结构&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字段类型优化&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 &lt;code&gt;username&lt;/code&gt; 和 &lt;code&gt;email&lt;/code&gt; 的长度调整为合理的值（如 50 和 100）。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;TIMESTAMP&lt;/code&gt; 替代 &lt;code&gt;DATETIME&lt;/code&gt;，节省空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;索引优化&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为 &lt;code&gt;username&lt;/code&gt; 和 &lt;code&gt;email&lt;/code&gt; 添加唯一索引。&lt;/li&gt;
&lt;li&gt;为 &lt;code&gt;last_login&lt;/code&gt; 添加普通索引，方便按最后登录时间查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;表分区&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按 &lt;code&gt;created_at&lt;/code&gt; 进行水平分区，按年或月分区。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;存储引擎选择&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;InnoDB&lt;/code&gt; 存储引擎，支持事务和行级锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;CREATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;users&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;INT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;PRIMARY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;KEY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;username&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;VARCHAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;50&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NOT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;UNIQUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;email&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;VARCHAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NOT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;UNIQUE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;created_at&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TIMESTAMP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NOT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;last_login&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TIMESTAMP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;INDEX&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;last_login&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ENGINE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;InnoDB&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RANGE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;YEAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;created_at&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2023&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2024&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2024&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2025&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p2025&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2026&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>为什么B&#43;Tree 存储千万级的数据只需要 3-4 层高度</title>
        <link>/zh-cn/post/2025/08/%E4%B8%BA%E4%BB%80%E4%B9%88b-tree-%E5%AD%98%E5%82%A8%E5%8D%83%E4%B8%87%E7%BA%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AA%E9%9C%80%E8%A6%81-3-4-%E5%B1%82%E9%AB%98%E5%BA%A6/</link>
        <pubDate>Sat, 30 Aug 2025 15:07:39 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/08/%E4%B8%BA%E4%BB%80%E4%B9%88b-tree-%E5%AD%98%E5%82%A8%E5%8D%83%E4%B8%87%E7%BA%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AA%E9%9C%80%E8%A6%81-3-4-%E5%B1%82%E9%AB%98%E5%BA%A6/</guid>
        <description>&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;MYSQL 一个页默认大小是 16KB，即 16384 字节。&lt;/li&gt;
&lt;li&gt;非叶子节点存储的是键值（索引）和指定子节点的指针，叶子节点存放行数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;假设&lt;/strong&gt;主键索引是 BigInt（对应 Long 类型），占 8 字节，子节点指针预计占 6 字节，那么一页的指针数量是 16384/（8+6）=1170 个，也就是可以指向 1170 个子数据页。&lt;/p&gt;
&lt;p&gt;那么第一层 1 个根节点指向第二层的 1170 个子数据页，第二层每个字数据页又指向第三层的 1170 个子数据页。所以第三层共 1170*1170=1368900 个数据页。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设&lt;/strong&gt;一条数据占 1KB，那么一个数据页能存储 16 条数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设&lt;/strong&gt;一共三层，那么第三层叶子节点共存储 1368900*16=21902400 条数据。已经达到 2 千万级。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意！！上述情况是假设，实际每条数据未必占用 1KB，那么 3 层的树高能存储更多数据，如果每条数据占用 512B 的话，那么 3 层能存储 21902400*2 条数据。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>MySQL的ACID分别如何实现</title>
        <link>/zh-cn/post/2025/08/mysql%E7%9A%84acid%E5%88%86%E5%88%AB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Fri, 29 Aug 2025 22:25:42 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/08/mysql%E7%9A%84acid%E5%88%86%E5%88%AB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;h2 id=&#34;原子性atomicity&#34;&gt;&lt;a href=&#34;#%e5%8e%9f%e5%ad%90%e6%80%a7atomicity&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;原子性（Atomicity）
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：事务是一个不可分割的工作单位，其中的操作要么全部执行，要么全部不执行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;：基于&lt;strong&gt;undo log（回滚日志）&lt;/strong&gt;。当事务对数据库进行修改时，InnoDB 会生成对应的 undo log。如果事务执行失败或调用&lt;code&gt;rollback&lt;/code&gt;，InnoDB 会利用 undo log 中的信息将数据回滚到修改之前的状态。undo log 记录了 SQL 执行的相关信息，包括被修改行的主键、修改的列以及修改前后的值等，回滚时根据这些信息执行与之前相反的操作。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;持久性durability&#34;&gt;&lt;a href=&#34;#%e6%8c%81%e4%b9%85%e6%80%a7durability&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;持久性（Durability）
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：事务一旦提交，其对数据库的改变应该是永久性的，即使在系统故障或宕机的情况下也不会丢失。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;：基于&lt;strong&gt;redo log（重做日志）&lt;/strong&gt;。当数据修改时，除了修改 Buffer Pool 中的数据，还会在 redo log 中记录这次操作。事务提交时，会调用&lt;code&gt;fsync&lt;/code&gt;接口将 redo log 刷盘。如果 MySQL 宕机，重启时可以通过读取 redo log 中的数据对数据库进行恢复。redo log 采用 WAL（Write-ahead logging，预写式日志）机制，即先写日志再更新数据，保证数据不会因 MySQL 宕机而丢失。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;隔离性isolation&#34;&gt;&lt;a href=&#34;#%e9%9a%94%e7%a6%bb%e6%80%a7isolation&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;隔离性（Isolation）
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：并发执行的事务之间不能互相干扰，事务内部的操作与其他事务隔离。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁&lt;/strong&gt;：通过锁机制保证不同事务之间的写操作不会冲突。InnoDB 支持行锁和表锁，行锁的粒度更细，性能更好。事务在修改数据之前需要先获得相应的锁，锁定的数据在事务提交或回滚之前不会被其他事务修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MVCC（多版本并发控制）&lt;/strong&gt;：用于解决写操作对读操作的影响。MVCC 通过以下技术实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;隐藏列&lt;/strong&gt;：每行数据包含隐藏列，记录事务 id 和指向 undo log 的指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;版本链&lt;/strong&gt;：通过 undo log 形成版本链，记录数据的多个版本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ReadView&lt;/strong&gt;：事务在读取数据时生成 ReadView，根据 ReadView 判断数据的可见性。ReadView 包含以下内容：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;low_limit_id&lt;/strong&gt;：生成 ReadView 时系统中下一个事务的 id，大于等于此 id 的事务对 ReadView 不可见。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;up_limit_id&lt;/strong&gt;：生成 ReadView 时系统中活跃事务的最小 id，小于此 id 的事务对 ReadView 可见。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rw_trx_ids&lt;/strong&gt;：活跃事务的 id 列表，用于判断事务是否在 ReadView 生成时活跃。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;一致性consistency&#34;&gt;&lt;a href=&#34;#%e4%b8%80%e8%87%b4%e6%80%a7consistency&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;一致性（Consistency）
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;依赖原子性、持久性和隔离性&lt;/strong&gt;：这三者是实现一致性的基础。如果事务的原子性、持久性和隔离性无法保证，一致性也无法保证。&lt;br&gt;
&lt;strong&gt;数据库层面的保障&lt;/strong&gt;：数据库本身提供数据类型、长度、外键约束等完整性检查。&lt;br&gt;
&lt;strong&gt;应用层面的保障&lt;/strong&gt;：应用逻辑需要保证事务的逻辑一致性，例如转账操作中，扣除和增加金额的逻辑必须正确。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;总结&#34;&gt;&lt;a href=&#34;#%e6%80%bb%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;总结
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;通过&lt;strong&gt;undo log&lt;/strong&gt;实现，确保事务的不可分割性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持久性&lt;/strong&gt;通过&lt;strong&gt;redo log&lt;/strong&gt;实现，确保事务提交后数据不会丢失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隔离性&lt;/strong&gt;通过&lt;strong&gt;锁机制&lt;/strong&gt;和&lt;strong&gt;MVCC&lt;/strong&gt;实现，确保并发事务之间的隔离。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一致性&lt;/strong&gt;依赖于其他三个特性，并结合数据库和应用层面的保障实现。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>Mysql的TimeStamp和DateTime异同</title>
        <link>/zh-cn/post/2025/08/mysql%E7%9A%84timestamp%E5%92%8Cdatetime%E5%BC%82%E5%90%8C/</link>
        <pubDate>Tue, 26 Aug 2025 00:00:00 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/08/mysql%E7%9A%84timestamp%E5%92%8Cdatetime%E5%BC%82%E5%90%8C/</guid>
        <description>&lt;h2 id=&#34;同&#34;&gt;&lt;a href=&#34;#%e5%90%8c&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;同
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;存储格式&lt;/strong&gt;：&lt;code&gt;YYYY-MM-DD HH:MM:SS&lt;/code&gt;，不包含时区信息&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;异&#34;&gt;&lt;a href=&#34;#%e5%bc%82&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;异
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;大小：TIMESTAMP占4字节，DATETIME占8字节&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;时区转换：TIMESTAMP则会根据服务器时区自动转换，DATETIME存储的值是固定的，不会根据时区自动转换&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;自动更新：TIMESTAMP支持自动更新，DATETIME就不支持自动更新，如：   CREATE TABLE users (       id INT AUTO_INCREMENT PRIMARY KEY,       username VARCHAR(50) NOT NULL,       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,       last_login TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP   );&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>慢SQL优化思路</title>
        <link>/zh-cn/post/2025/07/%E6%85%A2sql%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</link>
        <pubDate>Fri, 25 Jul 2025 15:15:06 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/07/%E6%85%A2sql%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;慢 SQL 通常指执行时间超过预设阈值的查询语句。不同业务场景对&amp;quot;慢&amp;quot;的定义可能不同，例如电商系统可能将超过 200ms 的查询视为慢查询，而数据分析系统可能将超过 5 秒的查询才视为慢查询。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;工具监控&#34;&gt;&lt;a href=&#34;#%e5%b7%a5%e5%85%b7%e7%9b%91%e6%8e%a7&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;工具监控
&lt;/h2&gt;&lt;p&gt;数据库系统通常提供内置的监控工具，如 MySQL 的慢查询日志和 Performance Schema。&lt;/p&gt;
&lt;p&gt;慢查询日志需要配置 long_query_time 参数来定义阈值，记录执行时间超过该值的查询。Performance Schema 能提供更详细的性能数据，包括查询执行时间、锁等待时间等指标。&lt;/p&gt;
&lt;p&gt;1）查看 Performance Schema 的配置信息&lt;/p&gt;
&lt;table border=&#34;0&#34; cellpadding=&#34;0&#34; cellspacing=&#34;0&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;1&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;code&gt;SHOW VARIABLES LIKE &lt;/code&gt;&lt;code&gt;&#39;performance_schema%&#39;&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;2）查看 Performance Schema 的监控项：&lt;/p&gt;
&lt;table border=&#34;0&#34; cellpadding=&#34;0&#34; cellspacing=&#34;0&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;1&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;code&gt;SELECT * FROM performance_schema.setup_instruments&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;3）查看 Performance Schema 收集的性能数据：&lt;/p&gt;
&lt;table border=&#34;0&#34; cellpadding=&#34;0&#34; cellspacing=&#34;0&#34;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;1&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;code&gt;SELECT * FROM performance_schema.events_statements_summary_by_digest&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;分析慢-sql&#34;&gt;&lt;a href=&#34;#%e5%88%86%e6%9e%90%e6%85%a2-sql&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;分析慢 SQL
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;explain&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000023565685&#34;  title=&#34;https://segmentfault.com/a/1190000023565685&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://segmentfault.com/a/1190000023565685&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;explain select * from user;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;|  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   23 |   100.00 | NULL  |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;select_type：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SIMPLE 简单查询，不包括子查询和&lt;code&gt;union&lt;/code&gt;查询&lt;/li&gt;
&lt;li&gt;PRIMARY 当存在子查询时，最外面的查询被标记为主查询&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUBQUERY&lt;/code&gt;  子查询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partitions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分区表命中的分区情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;type:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能的几种值：NULL &amp;gt; system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; ref_or_null &amp;gt; index_merge &amp;gt; range &amp;gt; index &amp;gt; ALL，越是靠左越好，&lt;code&gt;NULL&lt;/code&gt;  说明能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引，那么不查询索引也不查询表那你的数据是从哪里来的啊？如 select 5*7，是不需要查数据的，SELECT MAX(id) FROM table，MySQL 会直接到你的索引的分叶子节点上直接拿，所以不用访问表或者索引。&lt;code&gt;ref&lt;/code&gt;  则是单表扫描或者连接。&lt;code&gt;ref_or_null&lt;/code&gt;  类似 ref，但是可以搜索值为&lt;code&gt;NULL&lt;/code&gt;的行。&lt;code&gt;index_merge&lt;/code&gt;  表示查询使用了两个以上的索引。&lt;code&gt;range&lt;/code&gt;  索引范围查询。&lt;code&gt;index&lt;/code&gt; &lt;code&gt;index&lt;/code&gt;只遍历索引树，通常比&lt;code&gt;All&lt;/code&gt;快。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;possible_key：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能会使用的索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;key：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实际会使用的索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rows&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要查询的行数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;索引优化&#34;&gt;&lt;a href=&#34;#%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;索引优化
&lt;/h2&gt;&lt;p&gt;确保查询条件列和排序字段都有适当索引&lt;/p&gt;
&lt;h2 id=&#34;查询优化&#34;&gt;&lt;a href=&#34;#%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;查询优化
&lt;/h2&gt;&lt;p&gt;对于复杂查询，考虑拆分为多个简单查询&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Spring7个事务传播行为和5个隔离级别</title>
        <link>/zh-cn/post/2025/07/spring7%E4%B8%AA%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E5%92%8C5%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
        <pubDate>Sat, 19 Jul 2025 19:20:50 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/07/spring7%E4%B8%AA%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E5%92%8C5%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
        <description>&lt;h2 id=&#34;传播行为&#34;&gt;&lt;a href=&#34;#%e4%bc%a0%e6%92%ad%e8%a1%8c%e4%b8%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;传播行为
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;事务传播行为是为了解决业务层方法之间互相调用的事务问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务方法 A 被事务方法 B 调用，就要指定事务如何传播，是两者共用同一事务还是另起一个新事务。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_27184497/article/details/116525588&#34;  title=&#34;图解spring中七种事务传播行为 终于有人讲明白了_spring七种事务传播行为-CSDN博客&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;图解 spring 中七种事务传播行为 终于有人讲明白了_spring 七种事务传播行为-CSDN 博客&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1. REQUIRED&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@Transactional&lt;/code&gt;注解默认使用就是这个事务传播行为。&lt;/p&gt;
&lt;p&gt;如果当前存在事务，则&lt;strong&gt;加入&lt;/strong&gt;该事务；如果当前没有事务，则创建一个新的事务。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2. REQUIRES_NEW&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;另起炉灶。&lt;/strong&gt; 先创建一个&lt;strong&gt;新事务&lt;/strong&gt; ，如果当前存在事务则把当前事务&lt;strong&gt;挂起&lt;/strong&gt; 。也就是说不管外部方法是否开启事务，&lt;code&gt;Propagation.REQUIRES_NEW&lt;/code&gt;修饰的内部方法都会新开启自己的事务，且&lt;strong&gt;开启的事务相互独立，互不干扰。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;3. SUPPORTS&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;有事务就蹭，没事务就裸奔。&lt;/strong&gt; 如果当前存在事务，则&lt;strong&gt;加入&lt;/strong&gt;该事务；如果当前没有事务，以非事务的方式运行。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;4. NOT_SUPPORTED&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;不管有没有事务，必须裸奔。&lt;/strong&gt; 如果当前存在事务，则把当前事务&lt;strong&gt;挂起，以非事务执行&lt;/strong&gt;。如果当前没有事务，以非事务方式运行。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;5. MANDATORY（强制性）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;有事务就蹭，没事务就抛异常。&lt;/strong&gt; 如果当前存在事务，则&lt;strong&gt;加入&lt;/strong&gt;该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;6. NEVER&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果当前存在事务，则&lt;strong&gt;抛出异常&lt;/strong&gt;。如果当前没有事务，以非事务方式运行。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;7.NEST（嵌套）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果当前存在事务，则创建一个新事务作为当前事务的嵌套事务来运行；如果当前没有事务，则创建新事务。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;隔离级别&#34;&gt;&lt;a href=&#34;#%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;隔离级别
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;spring 的事务隔离级别和 mysql 几乎一模一样。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;DEFAULT&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用后端数据库默认隔离级别，Mysql 默认是可重复读&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;READ_UNCOMMITED&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最低的隔离级别，允许读取尚未提交的数据变更，有脏读、幻读、不可重复读的问题。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;READ_COMMITED&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;REPEATABLE_READ&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍&lt;strong&gt;有可能&lt;/strong&gt;发生。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;SERIALIZABLE&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就不产生干扰，阻止幻读。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>执行一条Select语句流程</title>
        <link>/zh-cn/post/2025/05/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B/</link>
        <pubDate>Mon, 19 May 2025 15:31:31 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/05/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/05/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B/image.png&#34;
	width=&#34;1261&#34;
	height=&#34;721&#34;
	srcset=&#34;/zh-cn/post/2025/05/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B/image_hu_e4172e541e27ce4b.png 480w, /zh-cn/post/2025/05/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B/image_hu_e391a59cf7b86378.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;419px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;查询缓存&#34;&gt;&lt;a href=&#34;#%e6%9f%a5%e8%af%a2%e7%bc%93%e5%ad%98&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;查询缓存
&lt;/h2&gt;&lt;p&gt;这里的查询缓存是 Server 层的，不是存储引擎层的 buffer pool，不过 Server 的缓存在 mysql8 之后被废弃了。&lt;/p&gt;
&lt;h2 id=&#34;解析-sql&#34;&gt;&lt;a href=&#34;#%e8%a7%a3%e6%9e%90-sql&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;解析 SQL
&lt;/h2&gt;&lt;p&gt;解析器会对 sql 进行词法分析、语法分析，构建语法树&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/05/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B/image-1.png&#34;
	width=&#34;1572&#34;
	height=&#34;800&#34;
	srcset=&#34;/zh-cn/post/2025/05/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B/image-1_hu_757ad01409a7ba12.png 480w, /zh-cn/post/2025/05/%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B/image-1_hu_9cd7e83bd7c798f7.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;196&#34;
		data-flex-basis=&#34;471px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;如果 sql 语法不对，就会在次阶段报错，如果是字段不存在则在此阶段是不会发现的。&lt;/p&gt;
&lt;h2 id=&#34;执行-sql&#34;&gt;&lt;a href=&#34;#%e6%89%a7%e8%a1%8c-sql&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;执行 SQL
&lt;/h2&gt;&lt;h3 id=&#34;prepare-阶段&#34;&gt;&lt;a href=&#34;#prepare-%e9%98%b6%e6%ae%b5&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;prepare 阶段
&lt;/h3&gt;&lt;p&gt;预处理器会检查 SQL 查询语句的表或字段是否存在&lt;/p&gt;
&lt;h3 id=&#34;optimize-阶段&#34;&gt;&lt;a href=&#34;#optimize-%e9%98%b6%e6%ae%b5&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;optimize 阶段
&lt;/h3&gt;&lt;p&gt;在优化阶段，优化器会为 SQL 指定执行计划，比如表中有多个索引，优化器会基于成本考虑选择使用哪个索引&lt;/p&gt;
&lt;h3 id=&#34;execute-阶段&#34;&gt;&lt;a href=&#34;#execute-%e9%98%b6%e6%ae%b5&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;execute 阶段
&lt;/h3&gt;&lt;p&gt;执行器会和存储引擎交互&lt;/p&gt;
</description>
        </item>
        <item>
        <title>MySQL为什么使用B&#43;树</title>
        <link>/zh-cn/post/2025/04/mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8b-%E6%A0%91/</link>
        <pubDate>Sat, 05 Apr 2025 09:39:19 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/04/mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8b-%E6%A0%91/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247502168&amp;amp;idx=1&amp;amp;sn=ff63afcea1e8835fca3fe7a97e6922b4&amp;amp;scene=21&amp;amp;poc_token=HEp7uWijzWxbzggsRmAOCYqdtfvrOjsqAUcgCVqD&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考此文章&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>MySQL性能优化</title>
        <link>/zh-cn/post/2025/04/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
        <pubDate>Sat, 05 Apr 2025 09:39:19 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/04/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
        <description>&lt;h2 id=&#34;抓住核心慢-sql-定位与分析&#34;&gt;&lt;a href=&#34;#%e6%8a%93%e4%bd%8f%e6%a0%b8%e5%bf%83%e6%85%a2-sql-%e5%ae%9a%e4%bd%8d%e4%b8%8e%e5%88%86%e6%9e%90&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;抓住核心：慢 SQL 定位与分析
&lt;/h2&gt;&lt;p&gt;性能优化的第一步永远是找到瓶颈。面试时，建议先从 &lt;strong&gt;慢 SQL 定位和分析&lt;/strong&gt; 入手，这不仅能展示你解决问题的思路，还能体现你对数据库性能监控的熟练掌握：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;监控工具：&lt;/strong&gt; 介绍常用的慢 SQL 监控工具，如 &lt;strong&gt;MySQL 慢查询日志&lt;/strong&gt;、&lt;strong&gt;Performance Schema&lt;/strong&gt; 等，说明你对这些工具的熟悉程度以及如何通过它们定位问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EXPLAIN 命令：&lt;/strong&gt; 详细说明 &lt;code&gt;EXPLAIN&lt;/code&gt; 命令的使用，分析查询计划、索引使用情况，可以结合实际案例展示如何解读分析结果，比如执行顺序、索引使用情况、全表扫描等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;由点及面索引表结构和-sql-优化&#34;&gt;&lt;a href=&#34;#%e7%94%b1%e7%82%b9%e5%8f%8a%e9%9d%a2%e7%b4%a2%e5%bc%95%e8%a1%a8%e7%bb%93%e6%9e%84%e5%92%8c-sql-%e4%bc%98%e5%8c%96&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;由点及面：索引、表结构和 SQL 优化
&lt;/h2&gt;&lt;p&gt;定位到慢 SQL 后，接下来就要针对具体问题进行优化。 这里可以重点介绍索引、表结构和 SQL 编写规范等方面的优化技巧：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;索引优化：&lt;/strong&gt; 这是 MySQL 性能优化的重点，可以介绍索引的创建原则、覆盖索引、最左前缀匹配原则等。如果能结合你项目的实际应用来说明如何选择合适的索引，会更加分一些。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表结构优化：&lt;/strong&gt; 优化表结构设计，包括选择合适的字段类型、避免冗余字段、合理使用范式和反范式设计等等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SQL 优化：&lt;/strong&gt; 避免使用 &lt;code&gt;SELECT *&lt;/code&gt;、尽量使用具体字段、使用连接查询代替子查询、合理使用分页查询、批量操作等，都是 SQL 编写过程中需要注意的细节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进阶方案架构优化&#34;&gt;&lt;a href=&#34;#%e8%bf%9b%e9%98%b6%e6%96%b9%e6%a1%88%e6%9e%b6%e6%9e%84%e4%bc%98%e5%8c%96&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;进阶方案：架构优化
&lt;/h2&gt;&lt;p&gt;当面试官对基础优化知识比较满意时，可能会深入探讨一些架构层面的优化方案。以下是一些常见的架构优化策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;读写分离：&lt;/strong&gt; 将读操作和写操作分离到不同的数据库实例，提升数据库的并发处理能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分库分表：&lt;/strong&gt; 将数据分散到多个数据库实例或数据表中，降低单表数据量，提升查询效率。但要权衡其带来的复杂性和维护成本，谨慎使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据冷热分离&lt;/strong&gt;：根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存机制：&lt;/strong&gt; 使用 Redis 等缓存中间件，将热点数据缓存到内存中，减轻数据库压力。这个非常常用，提升效果非常明显，性价比极高！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他优化手段&#34;&gt;&lt;a href=&#34;#%e5%85%b6%e4%bb%96%e4%bc%98%e5%8c%96%e6%89%8b%e6%ae%b5&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;其他优化手段
&lt;/h2&gt;&lt;p&gt;除了慢 SQL 定位、索引优化和架构优化，还可以提及一些其他优化手段，展示你对 MySQL 性能调优的全面理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连接池配置：&lt;/strong&gt; 配置合理的数据库连接池（如 &lt;strong&gt;连接池大小&lt;/strong&gt;、&lt;strong&gt;超时时间&lt;/strong&gt; 等），能够有效提升数据库连接的效率，避免频繁的连接开销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件配置：&lt;/strong&gt; 提升硬件性能也是优化的重要手段之一。使用高性能服务器、增加内存、使用 &lt;strong&gt;SSD&lt;/strong&gt; 硬盘等硬件升级，都可以有效提升数据库的整体性能。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>多版本并发控制MVCC</title>
        <link>/zh-cn/post/2025/04/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6mvcc/</link>
        <pubDate>Wed, 02 Apr 2025 09:39:19 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/04/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6mvcc/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_35190492/article/details/109044141&#34;  title=&#34;腾讯面试：MySQL事务与MVCC如何实现的隔离级别？_csdn三太子敖丙-CSDN博客&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;腾讯面试：MySQL 事务与 MVCC 如何实现的隔离级别？_csdn 三太子敖丙-CSDN 博客&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多版本并发控制  Multi-Version ConcurrencyControl，用于在&lt;strong&gt;多事务并发读写数据库时保持数据的一致性和隔离性&lt;/strong&gt;。它是&lt;strong&gt;通过在每个数据行上维护多个版本的数据来实现的&lt;/strong&gt;。当一个事务要对数据库中的数据进行修改时，MVCC 会&lt;strong&gt;为该事务创建一个数据快照，而不是直接修改实际的数据行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MVCC 不对数据加锁，因此如果是非锁定读（普通的 select 读）就读取快照数据，解决部分幻读，而对于锁定读，则读取的是当前数据，就需要使用临键锁锁住区间防止数据插入。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;通常对数据库的操作无非是增删改查、事务提交、回滚&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;读操作（SELECT）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务&lt;strong&gt;开始时&lt;/strong&gt;数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体工作情况如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。&lt;/li&gt;
&lt;li&gt;如果某个数据行有多个版本，&lt;strong&gt;事务会选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;写操作（INSERT、UPDATE、DELETE）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库。具体工作情况如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。&lt;/li&gt;
&lt;li&gt;新版本的数据带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。&lt;/li&gt;
&lt;li&gt;原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;事务提交和回滚&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。&lt;/li&gt;
&lt;li&gt;当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;版本的回收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了防止数据库中的版本无限增长，MVCC 会&lt;strong&gt;定期进行版本的回收&lt;/strong&gt;。回收机制会删除已经不再需要的旧版本数据，从而释放空间。&lt;/p&gt;
&lt;p&gt;MVCC 通过创建数据的多个版本和使用快照读取来实现并发控制。&lt;strong&gt;读操作使用旧版本数据的快照，写操作创建新版本&lt;/strong&gt;，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;非锁定读和锁定读&#34;&gt;&lt;a href=&#34;#%e9%9d%9e%e9%94%81%e5%ae%9a%e8%af%bb%e5%92%8c%e9%94%81%e5%ae%9a%e8%af%bb&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;非锁定读和锁定读
&lt;/h2&gt;&lt;h3 id=&#34;非锁定读&#34;&gt;&lt;a href=&#34;#%e9%9d%9e%e9%94%81%e5%ae%9a%e8%af%bb&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;非锁定读
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在 &lt;code&gt;InnoDB&lt;/code&gt; 存储引擎中，MVCC 就是对非锁定读的实现。如果读取的行正在执行 &lt;code&gt;DELETE&lt;/code&gt; 或 &lt;code&gt;UPDATE&lt;/code&gt; 操作，这时读取操作不会等行上锁的释放，而是读取行的快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Repeatable Read&lt;/code&gt; 和 &lt;code&gt;Read Committed&lt;/code&gt; 两个隔离级别下，如果是执行&lt;strong&gt;普通的 &lt;code&gt;select&lt;/code&gt; 语句&lt;/strong&gt;（不包括 &lt;code&gt;select ... lock in share mode&lt;/code&gt; ,&lt;code&gt;select ... for update&lt;/code&gt;）则会使用 &lt;code&gt;一致性非锁定读（MVCC）&lt;/code&gt;。并且在 &lt;code&gt;Repeatable Read&lt;/code&gt; 下 &lt;code&gt;MVCC&lt;/code&gt; 实现了可重复读和防止&lt;strong&gt;部分幻读&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;锁定读&#34;&gt;&lt;a href=&#34;#%e9%94%81%e5%ae%9a%e8%af%bb&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;锁定读
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如果执行的是下列语句，就是 锁定读&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;select ... lock in share mode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select ... for update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;update&lt;/code&gt;、&lt;code&gt;delete&lt;/code&gt; 操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在锁定读下，读取的是数据的最新版本，这种读也被称为&lt;strong&gt;当前读&lt;/strong&gt;。锁定读会对读取到的记录加锁。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;非锁定读&lt;/strong&gt;下，即使读取的记录已被其它事务加上 &lt;code&gt;X&lt;/code&gt; 锁，这时记录也是可以被读取的，因为&lt;strong&gt;此时读取的是快照数据&lt;/strong&gt;。在 &lt;code&gt;Repeatable Read&lt;/code&gt; 下 &lt;code&gt;MVCC&lt;/code&gt; &lt;strong&gt;防止了部分幻读，这边的 “部分”&lt;/strong&gt; 是指在 &lt;strong&gt;非锁定读&lt;/strong&gt;  情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是如果是&lt;strong&gt;当前读&lt;/strong&gt;，每次读取的都是最新数据，这时&lt;strong&gt;如果两次查询中间有其它事务插入数据，就会产生幻读&lt;/strong&gt;。所以， &lt;strong&gt;&lt;code&gt;InnoDB&lt;/code&gt; 在实现&lt;code&gt;Repeatable Read&lt;/code&gt; 时，如果执行的是当前读，则会对读取的记录使用 临键锁  ，来防止其它事务在间隙间插入数据&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;read-view&#34;&gt;&lt;a href=&#34;#read-view&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;&lt;strong&gt;Read View&lt;/strong&gt;
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ReadView 主要用来做可见性判断，里面保存了一些字段&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/04/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6mvcc/image.png&#34;
	width=&#34;850&#34;
	height=&#34;343&#34;
	srcset=&#34;/zh-cn/post/2025/04/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6mvcc/image_hu_d994d37b700980c4.png 480w, /zh-cn/post/2025/04/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6mvcc/image_hu_1d012962b71fa609.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;247&#34;
		data-flex-basis=&#34;594px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;读已提交和可重复读的隔离级别下-mvcc-差异&#34;&gt;&lt;a href=&#34;#%e8%af%bb%e5%b7%b2%e6%8f%90%e4%ba%a4%e5%92%8c%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e7%9a%84%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e4%b8%8b-mvcc-%e5%b7%ae%e5%bc%82&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;读已提交和可重复读的隔离级别下 MVCC 差异
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在事务隔离级别 &lt;code&gt;RC&lt;/code&gt; 和 &lt;code&gt;RR&lt;/code&gt;下，  通过&lt;code&gt;MVCC解决&lt;/code&gt;执行普通的 SEELCT 操作，但它们&lt;strong&gt;生成 &lt;code&gt;Read View&lt;/code&gt; 的时机却不同&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 RC 隔离级别下的&lt;strong&gt;每次&lt;code&gt;select&lt;/code&gt; 查询&lt;/strong&gt;前都生成一个&lt;code&gt;Read View&lt;/code&gt; (m_ids 列表)&lt;/li&gt;
&lt;li&gt;在 RR 隔离级别下只在事务开始后&lt;strong&gt;第一次&lt;code&gt;select&lt;/code&gt;&lt;/strong&gt; 数据前生成一个&lt;code&gt;Read View&lt;/code&gt;（m_ids 列表）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;mvcc临键锁防止幻读&#34;&gt;&lt;a href=&#34;#mvcc%e4%b8%b4%e9%94%ae%e9%94%81%e9%98%b2%e6%ad%a2%e5%b9%bb%e8%af%bb&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;MVCC+临键锁防止幻读
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1、执行普通 &lt;code&gt;select&lt;/code&gt;，此时会以 &lt;code&gt;MVCC&lt;/code&gt; 快照读的方式读取数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在快照读的情况下，RR 隔离级别只会&lt;strong&gt;在事务开启后的第一次查询生成 &lt;code&gt;Read View&lt;/code&gt;&lt;/strong&gt; ，并使用至事务提交。所以在生成 &lt;code&gt;Read View&lt;/code&gt; 之后其它事务所做的更新、插入记录版本对当前事务并&lt;strong&gt;不可见&lt;/strong&gt;，实现了可重复读和防止快照读下的 “幻读”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、执行 select&amp;hellip;for update/lock in share mode、insert、update、delete 等当前读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！&lt;code&gt;InnoDB&lt;/code&gt; 使用&lt;strong&gt;临键锁&lt;/strong&gt;来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>MySQL索引失效的几种场景、回表、索引覆盖、索引下推</title>
        <link>/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/</link>
        <pubDate>Sat, 15 Feb 2025 10:33:28 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/</guid>
        <description>&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;按「数据结构」分类：B+tree 索引、Hash 索引、Full-text 索引。&lt;/li&gt;
&lt;li&gt;按「物理存储」分类：聚簇索引（主键索引）、非聚簇索引（二级索引、辅助索引）。&lt;/li&gt;
&lt;li&gt;按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。&lt;/li&gt;
&lt;li&gt;按「字段个数」分类：单列索引、联合索引。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;聚簇索引和二级索引&#34;&gt;&lt;a href=&#34;#%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e5%92%8c%e4%ba%8c%e7%ba%a7%e7%b4%a2%e5%bc%95&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;聚簇索引和二级索引
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;innodb 使用 b+树作为索引数据结构。在创建表时，InnoDB &lt;strong&gt;默认会创建一个主键索引（primary key），也就是聚簇索引，而其它索引都属于二级索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果没有指明主键索引，就自动在后台创建 &lt;strong&gt;隐藏的 6 字节 row_id 列&lt;/strong&gt; 作为主键索引。&lt;/p&gt;
&lt;p&gt;值得一提的是，InnoDB 和 MyISAM 都支持 B+树索引，但是它们数据的存储结构实现方式不同。InnoDB 存储擎的 B+树索引的叶子节点保存数据本身（图 1），MylSAM 存储引擎的 B+树索引的叶子节点保存数据的物理地址（图 2）；&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image.png&#34;
	width=&#34;1080&#34;
	height=&#34;633&#34;
	srcset=&#34;/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image_hu_71e86be3883abdc8.png 480w, /zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image_hu_8fc3667f7bd5df4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;170&#34;
		data-flex-basis=&#34;409px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image-1.png&#34;
	width=&#34;914&#34;
	height=&#34;569&#34;
	srcset=&#34;/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image-1_hu_cca700ad0675f431.png 480w, /zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image-1_hu_97c6a84ec1ec53f5.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;160&#34;
		data-flex-basis=&#34;385px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;InnoDB 存储引擎根据索引类型不同，分为聚簇索引（图 1）和二级索引。区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户数据都存放在聚簇索引的叶子节点，而&lt;strong&gt;二级索引的叶子节点存放的是主键值，而不是实际数据&lt;/strong&gt;。如果将 name 字段设置为普通索引，那么这个&lt;strong&gt;二级索引&lt;/strong&gt;长下图这样：&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image-2.png&#34;
	width=&#34;1676&#34;
	height=&#34;872&#34;
	srcset=&#34;/zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image-2_hu_2941517050fef206.png 480w, /zh-cn/post/2025/02/mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF%E5%9B%9E%E8%A1%A8%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/image-2_hu_ad4f09b55f9cabec.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;192&#34;
		data-flex-basis=&#34;461px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;回表和索引覆盖&#34;&gt;&lt;a href=&#34;#%e5%9b%9e%e8%a1%a8%e5%92%8c%e7%b4%a2%e5%bc%95%e8%a6%86%e7%9b%96&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;回表和索引覆盖  
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果使用主键索引作为条件查询&lt;/strong&gt;，查询&lt;strong&gt;聚簇索引&lt;/strong&gt;的叶子节点数据（图 1），那么就直接在叶子节点读取到要查询的数据，比如 select * from user where id=1 (id 是主键索引)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果使用二级索引字段作为条件查询&lt;/strong&gt;，查询&lt;strong&gt;聚簇索引&lt;/strong&gt;的叶子节点数据，那么需要检索两颗 B+树：&lt;br&gt;
先在二级索引的 B+树找到对应的叶子节点，获取主键值（图 3），然后用获取的主键值，在聚簇索引中的 B+树检索到对应的叶子节点（图 1），然后获取要查询的数据。这个过程叫做&lt;strong&gt;回表&lt;/strong&gt;，如 select * from user where name=&amp;ldquo;林某&amp;rdquo;（name 是二级索引）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果使用二级索引字段作为条件查询&lt;/strong&gt;，&lt;strong&gt;查询二级索引的叶子节点数据&lt;/strong&gt;（图 3），那么只需在二级索引的 B+ 树找到对应的叶子节点，然后读取要查询的数据，不需要用到主键索引，这个过程叫做&lt;strong&gt;覆盖索引&lt;/strong&gt;。如 select id from user where name=&amp;ldquo;林某&amp;rdquo;（name 是二级索引，id 正好存在于二级索引中）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;索引失效场景&#34;&gt;&lt;a href=&#34;#%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e5%9c%ba%e6%99%af&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;索引失效场景
&lt;/h2&gt;&lt;h3 id=&#34;like-xx-或-like-xx&#34;&gt;&lt;a href=&#34;#like-xx-%e6%88%96-like-xx&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;like %xx 或 like %xx%
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。&lt;strong&gt;对索引使用左或左右模糊匹配，此时会走&lt;/strong&gt;全表扫描&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;对索引使用函数&#34;&gt;&lt;a href=&#34;#%e5%af%b9%e7%b4%a2%e5%bc%95%e4%bd%bf%e7%94%a8%e5%87%bd%e6%95%b0&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;对索引使用函数
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;select * from user where length(name)=3（name 是二级索引），因为索引保存的是索引字段原始值，而不是经过函数计算后的值，自然就没办法走索引了而是全表扫描。&lt;/p&gt;
&lt;p&gt;不过，从 MySQL8.0 开始，索引特性增加了函数索引，可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;对索引表达式计算&#34;&gt;&lt;a href=&#34;#%e5%af%b9%e7%b4%a2%e5%bc%95%e8%a1%a8%e8%be%be%e5%bc%8f%e8%ae%a1%e7%ae%97&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;对索引表达式计算
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;select * from from where id +1=10 会走全表扫描，因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，而 select * from from where id = 10 -1 则会走索引查询。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;对索引隐式类型转换&#34;&gt;&lt;a href=&#34;#%e5%af%b9%e7%b4%a2%e5%bc%95%e9%9a%90%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;对索引隐式类型转换
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话就会走全表扫描，而如果反过来，索引字段是整型，查询参数是字符串，此时会走索引，**因为 mysql 在字符串和整型比较时会自动把字符串变成数字，**所以字符串类型的索引，在使用整型参数查询时，还得把字符串索引变成整型才行，也就相当于调用了函数。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;联合索引不满足最左匹配&#34;&gt;&lt;a href=&#34;#%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95%e4%b8%8d%e6%bb%a1%e8%b6%b3%e6%9c%80%e5%b7%a6%e5%8c%b9%e9%85%8d&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;联合索引不满足最左匹配
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。那么**多个普通字段组合在一起创建的索引就叫做联合索引（组合索引），**在使用联合索引时要遵循最左匹配，比如创建联合索引（a,b,c），查询时 where b=1；where c=3；where b=2 and c=3；这三种情况都会使联合索引失效。&lt;/p&gt;
&lt;p&gt;有一个比较特殊的查询条件：&lt;strong&gt;where a = 1 and c = 3&lt;/strong&gt;，这属于&lt;strong&gt;索引截断&lt;/strong&gt;，不同版本处理方式也不一样。MySQL5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行交给 Server 层，在 Server 层再比对 c 字段的值。从 MySQL5.6 之后，有一个&lt;strong&gt;索引下推&lt;/strong&gt;，即在存储引擎层进行索引遍历时，对索引中包含的字段先做判断（a 和 c 都在索引中），直接过滤掉不满足条件的记录，再返还给 Server 层，从而&lt;strong&gt;减少回表次数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然&lt;strong&gt;回表只发生在用二级索引查询聚簇索引的数据&lt;/strong&gt;，如果用主键索引查聚簇索引的数据就不存在回表了。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;索引下推原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在(a,b,c)联合索引里的)，然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。&lt;/p&gt;
&lt;p&gt;没索引下推：存储引擎先定位到第一条 a=1 的数据，然后拿着其主键去回表，读取出数据给 server 层，然后 server 层判断是否满足 c=3，来决定是否给客户端，然后存储引擎重复上面操作，反复回表。&lt;br&gt;
有索引下推:    就直接在存储引擎层过滤，减少回表操作。&lt;/p&gt;
&lt;p&gt;联合索引的匹配遵循  &lt;strong&gt;最左前缀原则&lt;/strong&gt;，且  &lt;strong&gt;从最左列开始按顺序匹配&lt;/strong&gt;。当遇到第一个范围查询时，&lt;strong&gt;后续列的索引将不再生效&lt;/strong&gt;；而等值查询则允许后续列继续匹配索引，直到遇到范围查询为止。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;where-中使用-or&#34;&gt;&lt;a href=&#34;#where-%e4%b8%ad%e4%bd%bf%e7%94%a8-or&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;where 中使用 or
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在 WHERE 子句中，如果  OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;两个索引列做比较&#34;&gt;&lt;a href=&#34;#%e4%b8%a4%e4%b8%aa%e7%b4%a2%e5%bc%95%e5%88%97%e5%81%9a%e6%af%94%e8%be%83&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;两个索引列做比较
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 的索引（如 B+Tree 索引）是&lt;strong&gt;按列值单独排序&lt;/strong&gt;的。每个索引独立存储某列的值及其行位置（ROWID）。当比较两列时：&lt;/p&gt;
&lt;p&gt;若使用  &lt;code&gt;column1&lt;/code&gt;  的索引，只能快速定位到  &lt;code&gt;column1&lt;/code&gt;  的特定值，但无法直接关联到  &lt;code&gt;column2&lt;/code&gt;  的值。同理，&lt;code&gt;column2&lt;/code&gt;  的索引也无法关联到  &lt;code&gt;column1&lt;/code&gt;  的值。优化器无法通过索引直接找到满足  &lt;code&gt;column1 = column2&lt;/code&gt;  的行，只能通过全表扫描逐行比较。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;不等于比较&#34;&gt;&lt;a href=&#34;#%e4%b8%8d%e7%ad%89%e4%ba%8e%e6%af%94%e8%be%83&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;不等于比较
&lt;/h3&gt;&lt;h3 id=&#34;is-not-null&#34;&gt;&lt;a href=&#34;#is-not-null&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;is not null
&lt;/h3&gt;&lt;h3 id=&#34;not-in-和-not-exists&#34;&gt;&lt;a href=&#34;#not-in-%e5%92%8c-not-exists&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;not in 和 not exists
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;查询条件使用 not in 时，如果是主键索引则走索引，如果是普通索引，则索引失效。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;order-by&#34;&gt;&lt;a href=&#34;#order-by&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;order by
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对索引 order by 导致全表排序&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>MySQL三大日志</title>
        <link>/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/</link>
        <pubDate>Fri, 24 Jan 2025 21:03:52 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;常见的 mysql 日志有二进制日志 binlog（归档日志）和重做日志 redo log（事务日志）和 undo log（回滚日志）。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image.png&#34;
	width=&#34;1407&#34;
	height=&#34;310&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image_hu_c5edda36ce4b3de7.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image_hu_77625b95d3216b77.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;453&#34;
		data-flex-basis=&#34;1089px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;undo-log-回滚日志&#34;&gt;&lt;a href=&#34;#undo-log-%e5%9b%9e%e6%bb%9a%e6%97%a5%e5%bf%97&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;undo log 回滚日志
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;undo log 保证了事务的原子性&lt;/strong&gt;，undo log 的信息也会被记录到 redo log 中，因为 undo log 也要实现持久性保护。&lt;br&gt;
每当 innoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在插入一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录删掉就好了；&lt;/li&gt;
&lt;li&gt;在删除一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了；&lt;/li&gt;
&lt;li&gt;在更新一条记录时，要把被更新的列的旧值记下来，这祥样之后回滚时再把这些列更新为旧值就好了。
&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-1.png&#34;
	width=&#34;352&#34;
	height=&#34;571&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-1_hu_e088fd4123d60716.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-1_hu_7ddca99daf083009.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;61&#34;
		data-flex-basis=&#34;147px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;readviewundo-log-实现-mvcc&#34;&gt;&lt;a href=&#34;#readviewundo-log-%e5%ae%9e%e7%8e%b0-mvcc&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;ReadView+undo log 实现 MVCC
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在读已提交和可重复读的隔离级别，普通读是通过 ReadView+undo log 实现的
&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-2.png&#34;
	width=&#34;1411&#34;
	height=&#34;628&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-2_hu_fb1f02189ebebcf3.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-2_hu_1afbf579a2a402a.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;224&#34;
		data-flex-basis=&#34;539px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;buffer-pool&#34;&gt;&lt;a href=&#34;#buffer-pool&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Buffer Pool
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 的数据都是存在磁盘中的，那么更新一条记录的时候，得先要从磁盘读取该&lt;br&gt;
记录，然后在内存中修改这条记录。&lt;strong&gt;那修改完这条记录是选择直接写回到磁盘，还是选择缓存起来呢？&lt;/strong&gt;&lt;br&gt;
当然是缓存起来好，这样下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了。为此，Innodb 存储引擎设计了一个 Buffer Pool，来提高数据库的读写性能。当修改数据时，&lt;strong&gt;如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页&lt;/strong&gt;（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘 IO，不会立即将脏页写入磁盘，后续由后台线程选择一个&lt;strong&gt;合适的时机&lt;/strong&gt;将脏页写入到磁盘。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;redo-log-重做日志&#34;&gt;&lt;a href=&#34;#redo-log-%e9%87%8d%e5%81%9a%e6%97%a5%e5%bf%97&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;redo log 重做日志
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 中数据是以页为单位，查询一条记录会&lt;strong&gt;从硬盘把一页的数据加载出来&lt;/strong&gt;，加载出来的数据叫&lt;strong&gt;数据页&lt;/strong&gt;，会放入到 &lt;strong&gt;&lt;code&gt;Buffer Pool&lt;/code&gt;&lt;/strong&gt; 中。&lt;/p&gt;
&lt;p&gt;后续的查询都是先从 &lt;code&gt;Buffer Pool&lt;/code&gt; 中找，没有命中再去硬盘加载，&lt;strong&gt;减少硬盘 IO 开销&lt;/strong&gt;，提升性能。&lt;/p&gt;
&lt;p&gt;更新表数据的时候，也是先更新&lt;code&gt;Buffer Pool&lt;/code&gt; 的数据，如果没有则先把数据读到&lt;code&gt;Buffer Pool&lt;/code&gt;&lt;strong&gt;。&lt;strong&gt;然后会把“在某个数据页上做了什么修改”记录到&lt;code&gt;redo log buffer&lt;/code&gt;，接着&lt;/strong&gt;刷盘到 redo log&lt;/strong&gt; 文件里。
&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-3.png&#34;
	width=&#34;1234&#34;
	height=&#34;724&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-3_hu_f42a7e1a8f01dc.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-3_hu_9764915eb673c85c.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;170&#34;
		data-flex-basis=&#34;409px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;那么&lt;strong&gt;什么时候会进行刷盘&lt;/strong&gt;呢？别急，往后看！&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;为什么需要-redo-log&#34;&gt;&lt;a href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-redo-log&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;为什么需要 redo log
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为了防止 buffer pool 的脏页丢失而设计&lt;/strong&gt;。buffer pool 基于内存，提高了 mysql 性能，但是内存的数据没有持久化到磁盘，mysql 宕机后会数据丢失，为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会**先更新内存并标记为脏页，然后将本次对页的修改以 redo log 的形式记录下&lt;br&gt;
来，**这个时候更新就算完成了。&lt;br&gt;
后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘&lt;br&gt;
里，这就是 WAL(Write-Ahead Logging)技术。WAL 技术指的是，MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。
&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-4.png&#34;
	width=&#34;1292&#34;
	height=&#34;977&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-4_hu_b38e36e8563d6c3e.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-4_hu_d15426903c5875b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;132&#34;
		data-flex-basis=&#34;317px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;刷盘时机&#34;&gt;&lt;a href=&#34;#%e5%88%b7%e7%9b%98%e6%97%b6%e6%9c%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;刷盘时机
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;事务提交：当事务提交时，log buffer 里的 redo log 会被刷新到磁盘（可以通过&lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;参数控制，后文会提到）。&lt;/li&gt;
&lt;li&gt;log buffer 空间不足时：log buffer 中缓存的 redo log 已经占满了 log buffer 总容量的大约&lt;strong&gt;一半&lt;/strong&gt;左右，就需要把这些日志刷新到磁盘上。&lt;/li&gt;
&lt;li&gt;Checkpoint（检查点）：InnoDB 定期会执行检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。&lt;/li&gt;
&lt;li&gt;后台刷新线程：InnoDB 启动了一个后台线程，负责周期性（每隔 1 秒）地将脏页（已修改但尚未写入磁盘的数据页）fsync 刷新到磁盘，并将相关的重做日志一同刷新。&lt;/li&gt;
&lt;li&gt;正常关闭服务器：MySQL 关闭的时候，redo log 都会刷入到磁盘里去。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;redo-log-要写到磁盘数据也要写磁盘为什么要多此一举&#34;&gt;&lt;a href=&#34;#redo-log-%e8%a6%81%e5%86%99%e5%88%b0%e7%a3%81%e7%9b%98%e6%95%b0%e6%8d%ae%e4%b9%9f%e8%a6%81%e5%86%99%e7%a3%81%e7%9b%98%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%a4%9a%e6%ad%a4%e4%b8%80%e4%b8%be&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;写入 redo log 的方式使用了追加操作，是顺序写，而磁盘写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。「顺序写」比「随机写」高效的多，因此 redo log 写入磁盘的开销更小。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;修改数据页后脏页为何不直接刷盘还需要-redo-log&#34;&gt;&lt;a href=&#34;#%e4%bf%ae%e6%94%b9%e6%95%b0%e6%8d%ae%e9%a1%b5%e5%90%8e%e8%84%8f%e9%a1%b5%e4%b8%ba%e4%bd%95%e4%b8%8d%e7%9b%b4%e6%8e%a5%e5%88%b7%e7%9b%98%e8%bf%98%e9%9c%80%e8%a6%81-redo-log&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;修改数据页后（脏页）为何不直接刷盘，还需要 redo log
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;数据页大小是 16kb，刷盘（&lt;strong&gt;随机写&lt;/strong&gt;）要进行 io 比较耗时，如果仅修改了数据页几 byte 的数据，没必要刷盘。而写 red log  一行记录（&lt;strong&gt;顺序写&lt;/strong&gt;）可能就占几十  &lt;code&gt;Byte&lt;/code&gt;，相对来说更优。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;redolog 采用循环写，边写边擦除日志，只记录未被刷入磁盘的数据 ，已刷入磁盘的数据会从 redolog 中擦除，而 binlog 保存的全量日志，如果整个数据库都删除了，可以用 binlog 恢复数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了，这时候擦除这些旧记录，以腾出空间记录新的更新操作。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-5.png&#34;
	width=&#34;1335&#34;
	height=&#34;495&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-5_hu_eaba9717e79ce6c5.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-5_hu_c0d652cd1a61c7d7.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;269&#34;
		data-flex-basis=&#34;647px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;bin-log-归档日志&#34;&gt;&lt;a href=&#34;#bin-log-%e5%bd%92%e6%a1%a3%e6%97%a5%e5%bf%97&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;bin log 归档日志
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;redo log 是&lt;strong&gt;物理日志&lt;/strong&gt;，记录内容是“&lt;strong&gt;在某个数据页上做了什么修改&lt;/strong&gt;”，属于 InnoDB 存储引擎。&lt;/p&gt;
&lt;p&gt;binlog 是&lt;strong&gt;逻辑日志&lt;/strong&gt;，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于&lt;code&gt;MySQL Server&lt;/code&gt;  层，会记录所有涉及更新数据的逻辑操作，并且是&lt;strong&gt;顺序写&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;binlog 日志有三种格式，由 binlog_format 指定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;statement&lt;br&gt;
记录 SQL 原文，这样同步数据时仅需执行 SQL 即可，但是如果 SQL 中有 now()，那么此时同步获取的时间和原库的时间是不一致的。因此在同步数据时，需要指定为 row 格式，不仅记录 SQL，还包含具体数据，即把 now()变成具体时间戳&lt;/li&gt;
&lt;li&gt;row&lt;br&gt;
记录 SQL 和具体数据，因此这种格式会占用更多的空间，恢复与同步时会更消耗 IO 资源，影响执行速度。&lt;/li&gt;
&lt;li&gt;mixed&lt;br&gt;
前两者混合&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;bin-log-刷盘时机&#34;&gt;&lt;a href=&#34;#bin-log-%e5%88%b7%e7%9b%98%e6%97%b6%e6%9c%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;bin log 刷盘时机  
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;事务执行过程中，先把日志 write 到&lt;code&gt;binlog cache&lt;/code&gt;，事务提交的时，再把&lt;code&gt;binlog cache fsync到&lt;/code&gt;binlog 文件中。&lt;/p&gt;
&lt;p&gt;因为一个事务的 binlog 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会&lt;strong&gt;给每个线程分配一个&lt;code&gt;binlog cache&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;binlog_cache_size&lt;/code&gt;参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（&lt;code&gt;Swap&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-6.png&#34;
	width=&#34;1238&#34;
	height=&#34;916&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-6_hu_92a3da250b4b9bbe.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-6_hu_2fc79d97a20919ec.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;135&#34;
		data-flex-basis=&#34;324px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;两阶段提交&#34;&gt;&lt;a href=&#34;#%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;两阶段提交
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在执行更新语句过程，会记录 redo log 与 binlog 两块日志，以基本的事务为单位，&lt;strong&gt;redo log&lt;/strong&gt; &lt;strong&gt;在事务执行过程中可以不断写入&lt;/strong&gt;，而 binlog 只有&lt;strong&gt;在提交事务时才写入&lt;/strong&gt;，所以 redo log 与 binlog 的写入时机不一样。&lt;br&gt;
如果在写完 redolog 日志后，binlog 日志写期间发生异常，就会导致数据不一致。对此 innodb 采用两阶段提交方案（XA 事务），把 redo log 写入拆成 prepare 和 commit 两阶段
&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-7.png&#34;
	width=&#34;1157&#34;
	height=&#34;842&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-7_hu_e2256c06902a886f.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-7_hu_95975fb7f15b9792.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;137&#34;
		data-flex-basis=&#34;329px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这样 binlog 写期间发生异常，redolog 还处于 prepare 阶段，回滚事务。&lt;br&gt;
而如果 binlog 期间无异常，commit 期间异常，就不会回滚事务，因为 binlog 日志已经记录成功，mysql 就认为是完整的，会提交事务恢复数据。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;异常重启出现什么现象&#34;&gt;&lt;a href=&#34;#%e5%bc%82%e5%b8%b8%e9%87%8d%e5%90%af%e5%87%ba%e7%8e%b0%e4%bb%80%e4%b9%88%e7%8e%b0%e8%b1%a1&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;异常重启出现什么现象
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-8.png&#34;
	width=&#34;1175&#34;
	height=&#34;842&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-8_hu_c5b73f0f131b7a72.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-8_hu_b11c5617c415750d.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;139&#34;
		data-flex-basis=&#34;334px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;A、B 两个时刻，redo log 都处于 prepare 阶段，mysql 重启后会扫描 redo log，碰到处于 prepare 阶段的 redo log，就会拿着他的事务 id 去 bin log 查是否存在此 id，若不存在，则说明 binlog 还没有刷盘，回滚事务，若存在，则说明 binlog 已经刷盘，提交事务。如此便可保证两个日志的一致性。&lt;/p&gt;
&lt;h2 id=&#34;事务没提交的时候redo-log-会被持久化到磁盘吗&#34;&gt;&lt;a href=&#34;#%e4%ba%8b%e5%8a%a1%e6%b2%a1%e6%8f%90%e4%ba%a4%e7%9a%84%e6%97%b6%e5%80%99redo-log-%e4%bc%9a%e8%a2%ab%e6%8c%81%e4%b9%85%e5%8c%96%e5%88%b0%e7%a3%81%e7%9b%98%e5%90%97&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;事务没提交的时候，redo log 会被持久化到磁盘吗？
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-9.png&#34;
	width=&#34;1306&#34;
	height=&#34;731&#34;
	srcset=&#34;/zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-9_hu_ccb8ccb14665f8be.png 480w, /zh-cn/post/2025/01/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/image-9_hu_de7b52421e169b43.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;178&#34;
		data-flex-basis=&#34;428px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;&lt;a href=&#34;#%e6%80%bb%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;总结
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL InnoDB 引擎使用 &lt;strong&gt;redo log(重做日志)&lt;/strong&gt; 保证事务的&lt;strong&gt;持久性&lt;/strong&gt;，使用 &lt;strong&gt;undo log(回滚日志)&lt;/strong&gt; 来保证事务的&lt;strong&gt;原子性&lt;/strong&gt;，这两个都是存储引擎层面的。&lt;/p&gt;
&lt;p&gt;MySQL 数据库的&lt;strong&gt;数据备份、主备、主主、主从&lt;/strong&gt;都离不开 binlog，需要依靠 binlog 来同步数据，保证数据一致性，是 Server 层面的，所有存储引擎都可以使用。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>MySQL四种事务隔离机制</title>
        <link>/zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Fri, 27 Dec 2024 12:00:00 +0000</pubDate>
        
        <guid>/zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;何为事务？&lt;/strong&gt; 一言蔽之，&lt;strong&gt;事务是逻辑上的一组操作，要么都执行，要么都不执行。&lt;/strong&gt; &amp;gt; &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原子性&lt;/strong&gt; （&lt;code&gt;Atomicity&lt;/code&gt;）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt; （&lt;code&gt;Consistency&lt;/code&gt;）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性&lt;/strong&gt; （&lt;code&gt;Isolation&lt;/code&gt;）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久性&lt;/strong&gt; （&lt;code&gt;Durability&lt;/code&gt;）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://time.geekbang.org/opencourse/intro/100064201&#34;  title=&#34;周志明的软件架构课_软件架构_分布式系统_基础设施_架构演进_单体架构_SOA架构_微服务_云原生-极客时间&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;周志明的软件架构课&lt;em&gt;软件架构&lt;/em&gt;分布式系统&lt;em&gt;基础设施&lt;/em&gt;架构演进&lt;em&gt;单体架构_SOA 架构&lt;/em&gt;微服务_云原生-极客时间&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/image.png&#34;
	width=&#34;768&#34;
	height=&#34;802&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/image_hu_d5e27402bc12d27a.png 480w, /zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/image_hu_1d47680f91659ae3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;229px&#34;
	
&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;并发事务的问题&#34;&gt;&lt;a href=&#34;#%e5%b9%b6%e5%8f%91%e4%ba%8b%e5%8a%a1%e7%9a%84%e9%97%ae%e9%a2%98&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;并发事务的问题
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;丢失修改：&lt;/strong&gt; 在事务 1 读取一个数据时，另外事务 2 也访问了该数据，那么在事务 1 中修改了这个数据后，事务 2 也修改了这个数据。这样事务 1 的修改结果就被丢失，因此称为丢失修改。
&lt;ul&gt;
&lt;li&gt;**例：**事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20。事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;脏读：&lt;/strong&gt; 事务 2 读取了事务 1 未提交的数据
&lt;ul&gt;
&lt;li&gt;**例：**事务 1 读取某表中的数据 A=20 并修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并未提交到数据库， A 的值还是 20&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可重复读：&lt;/strong&gt; 事务 1 多次读同一数据。在事务 1 还没有结束时，事务 2 也访问该数据。那么，在事务 1 中的两次读数据之间，由于事务 2 的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
&lt;ul&gt;
&lt;li&gt;**例：**事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;幻读：&lt;/strong&gt; 幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
&lt;ul&gt;
&lt;li&gt;**例：**事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;并发事务控制方式&#34;&gt;&lt;a href=&#34;#%e5%b9%b6%e5%8f%91%e4%ba%8b%e5%8a%a1%e6%8e%a7%e5%88%b6%e6%96%b9%e5%bc%8f&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;并发事务控制方式
&lt;/h2&gt;&lt;p&gt;MySQL 中并发事务的控制方式无非就两种：&lt;strong&gt;锁&lt;/strong&gt; 和 &lt;strong&gt;MVCC&lt;/strong&gt;。锁可以看作是悲观控制的模式，多版本并发控制可以看作是乐观控制的模式。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html&#34;  title=&#34;InnoDB存储引擎对MVCC的实现 | JavaGuide&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;InnoDB 存储引擎对 MVCC 的实现 | JavaGuide&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;锁&lt;/strong&gt; 控制方式下会通过锁来显式控制共享资源而不是通过调度手段，MySQL 中主要是通过 &lt;strong&gt;读写锁&lt;/strong&gt; 来实现并发控制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;共享锁（S 锁）&lt;/strong&gt;：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排他锁（X 锁）&lt;/strong&gt;：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。
&lt;strong&gt;MVCC&lt;/strong&gt; 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MVCC 在 MySQL 中实现所依赖的手段主要是: &lt;strong&gt;隐藏字段、read view、undo log&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;四个事务隔离级别&#34;&gt;&lt;a href=&#34;#%e5%9b%9b%e4%b8%aa%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;四个事务隔离级别
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2014/08/20/innodb-lock.html&#34;  title=&#34;Innodb中的事务隔离级别和锁的关系 - 美团技术团队&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Innodb 中的事务隔离级别和锁的关系 - 美团技术团队&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;读已提交和 可重复读 隔离级别是基于 MVCC 实现的，可串行化 隔离级别是通过锁来实现的。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;读未提交-read-uncommitted&#34;&gt;&lt;a href=&#34;#%e8%af%bb%e6%9c%aa%e6%8f%90%e4%ba%a4-read-uncommitted&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;读未提交 (Read Uncommitted)
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;特点：在该隔离级别下，一个事务可以读取另一个事务尚未提交的数据。这就会导致脏读，即一个事务读取到的可能是另一个事务未提交的修改，这些修改可能会被回滚。&lt;/li&gt;
&lt;li&gt;问题：事务 B 读取到事务 A 修改的值，但事务 A 回滚后，数据实际上没有变化。发生了&lt;strong&gt;脏读。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;读已提交-read-committed&#34;&gt;&lt;a href=&#34;#%e8%af%bb%e5%b7%b2%e6%8f%90%e4%ba%a4-read-committed&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;读已提交 (Read Committed)
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特点：在该隔离级别下，一个事务只能读取到已提交事务的数据，因此脏读不会发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题：事务 A 在读取两次同一数据时，第二次读取的数据可能会&lt;strong&gt;因其他事务的提交而发生变化&lt;/strong&gt; ，这就是&lt;strong&gt;不可重复读&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;「读已提交」事务期间的多次读取同一条数据，&lt;strong&gt;前后两次读的数据可能会出现不一致&lt;/strong&gt; ，因为可能这期间另外一个事务修改了该记录，并提交了事务。&lt;strong&gt;这就是不可重复读的问题&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;可重复读-repeatable-read&#34;&gt;&lt;a href=&#34;#%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb-repeatable-read&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;可重复读 (Repeatable Read)
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;特点：在该隔离级别下，事务会看到在事务开始时一致的&lt;strong&gt;数据快照&lt;/strong&gt;，不可重复读的问题被解决。&lt;/li&gt;
&lt;li&gt;问题：如果事务 A 查询范围的数据（例如某一时间段内的所有交易记录），事务 B&lt;strong&gt;插入&lt;/strong&gt; 的新数据可能会被事务 A 在第二次查询中看到，导致事务 A 两次查询到的数据量不一致，这就是&lt;strong&gt;幻读，可重复读仅解决部分幻读&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;用 Read View 只能保证&amp;quot;快照读&amp;quot;不幻读；一旦事务里出现&amp;quot;当前读&amp;quot;（UPDATE/DELETE/SELECT &amp;hellip; FOR UPDATE 等），就会重新加 Next-Key Lock，这时若别的事务新插入的记录落在这个锁范围里，就可能被本事务再次看到，于是出现&amp;quot;部分幻读&amp;quot;。
「可重复读」隔离级别是&lt;strong&gt;启动事务时生成一个 Read View，然后整个事务期间都在用
这个 Read View&lt;/strong&gt; ，这样就保证了在事务期间读到的数据都是事务启动前的记录。&lt;strong&gt;解决了不可重复读和部分幻读。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;串行化-serializable&#34;&gt;&lt;a href=&#34;#%e4%b8%b2%e8%a1%8c%e5%8c%96-serializable&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;串行化 (Serializable)
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;特点：在该隔离级别下，&lt;strong&gt;事务是完全隔离、串行执行&lt;/strong&gt;。其他事务必须等当前事务完成才能开始执行，这避免了所有并发问题（脏读、不可重复读和幻读），但也大大降低了性能。
&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/image-1.png&#34;
	width=&#34;1080&#34;
	height=&#34;464&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/image-1_hu_f56d88340cfa1784.png 480w, /zh-cn/post/2024/12/mysql%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/image-1_hu_fdbd2950bc1baf4f.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;232&#34;
		data-flex-basis=&#34;558px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;幻读&#34;&gt;&lt;a href=&#34;#%e5%b9%bb%e8%af%bb&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;幻读
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;幻读 VS 不可重复读&lt;/strong&gt;&lt;br&gt;
幻读重点在于&lt;strong&gt;数据是否存在&lt;/strong&gt;。原本不存在的数据却真实的存在了，这便是幻读。引起幻读的原因在于另一个事务进行了 INSERT 操作。&lt;/li&gt;
&lt;li&gt;不可重复读重点在于&lt;strong&gt;数据值是否被改变&lt;/strong&gt;。在一个事务中对同一条记录进行查询，第一次读取到的数据和第二次读取到的数据不一致，这便是可重复读。引起不可重复读的原因在于另一个事务进行了 UPDATE 或者是 DELETE 操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说：幻读是说数据的条数发生了变化，原本不存在的数据存在了。不可重复读是说数据的内容发生了变化，原本存在的数据的内容发生了改变。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可重复读隔离下为什么会产生幻读&lt;/strong&gt;&lt;br&gt;
在可重复读隔离级别下，普通的查询是&lt;strong&gt;快照读&lt;/strong&gt; ，是不会看到别的事务插入的数据的，&lt;strong&gt;就没有幻读&lt;/strong&gt; 。因此，幻读在 &lt;strong&gt;当前读（&lt;/strong&gt; select &amp;hellip; for update 等语句，使用临键锁**）** 下才会出现。&lt;br&gt;
MySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete,这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MySQL 中如何实现可重复读&lt;/strong&gt;&lt;br&gt;
当隔离级别为可重复读的时候，事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View。也就是说：不管其他事务怎么修改数据，，对于 A 事务而言，它能看到的数据永远都是第一次 SELECT 时看到的数据。这显然不合理，如果其它事务插入了数据，A 事务却只能看到过去的数据，读取不了当前的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解决幻读的办法&lt;/strong&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/mysql/transaction/phantom.html&#34;  title=&#34;MySQL 可重复读隔离级别，完全解决幻读了吗？ | 小林coding&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL 可重复读隔离级别，完全解决幻读了吗？ | 小林 coding&lt;/a&gt;{#解决幻读的方法}&lt;/p&gt;
&lt;p&gt;**解决幻读的核心思想就是事务 A 在操作某张表数据的时候，另外事务 B 不允许新增或者删除这张表中的数据。**解决幻读的方式主要有以下几种：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将事务隔离级别调整为 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在可重复读的事务级别下，给事务操作的这张表添加表锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在可重复读的事务级别下，给事务操作的这张表添加 临键锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;其他情况下的幻读&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成一个数据快照，之后事务 B 向表中新插入了一条 id=5 的记录并提交（此时是当前读）。接着，事务 A 对 id=5 这条记录进行了更新操作（看不见但是能更新），在这个时刻这条新记录的 trx id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务 A 先快照读，得到数据量为 3，然后事务 B 插入一条数据并提交事务，事务 A 使用当前读得到的数量就是 4 了，前后数据量不对。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>MySQL入门概述</title>
        <link>/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/</link>
        <pubDate>Thu, 26 Dec 2024 14:43:23 +0000</pubDate>
        
        <guid>/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;MySQL 是建立在关系模型基础上的关系型数据库，关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;字段类型&#34;&gt;&lt;a href=&#34;#%e5%ad%97%e6%ae%b5%e7%b1%bb%e5%9e%8b&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;字段类型
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image.png&#34;
	width=&#34;1654&#34;
	height=&#34;1426&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image_hu_8d67505423ab9cf5.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image_hu_fe9bc902be500416.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;115&#34;
		data-flex-basis=&#34;278px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;TINYINT 占 1 字节，INT 占 4 字节，BIGINT 占 8 字节。&lt;/li&gt;
&lt;li&gt;CHAR 是定长字符串，VARCHAR 是变长字符串。CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR 在存储时需要使用 1 或 2 个额外&lt;strong&gt;字节&lt;/strong&gt; 记录字符串的长度，检索时不需要处理。&lt;strong&gt;CHAR（100）指的是 100 个字符而非字节&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MySQL 中字符的存储是与字符集（&lt;code&gt;CHARSET&lt;/code&gt;）相关的，具体的字节数取决于你使用的字符集和编码。 &lt;strong&gt;&lt;code&gt;latin1&lt;/code&gt;&lt;/strong&gt; 编码（单字节编码），每个字符占用 &lt;strong&gt;1 字节&lt;/strong&gt; 。&lt;strong&gt;&lt;code&gt;utf8mb4&lt;/code&gt;&lt;/strong&gt; 编码（变长编码），每个字符可能占用 &lt;strong&gt;1 到 4 字节&lt;/strong&gt;，具体取决于字符的内容。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;varchar100和-varchar10区别&#34;&gt;&lt;a href=&#34;#varchar100%e5%92%8c-varchar10%e5%8c%ba%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;VARCHAR(100)和 VARCHAR(10)区别
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;VARCHAR(100)和 VARCHAR(10)都是变长类型，表示能存储最多 100 个字符和 10 个字符。但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，其所占用的磁盘空间是基于&lt;strong&gt;实际存储的字符长度&lt;/strong&gt;，而不是字段的最大长度。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;decimal-和-floatdouble-区别&#34;&gt;&lt;a href=&#34;#decimal-%e5%92%8c-floatdouble-%e5%8c%ba%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;DECIMAL 和 FLOAT/DOUBLE 区别
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;DECIMAL 是定点数，可以存储精确的小数值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FLOAT（4 字节），DOUBLE（8 字节） 是浮点数，只能存储近似的小数值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;text-和-blob&#34;&gt;&lt;a href=&#34;#text-%e5%92%8c-blob&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;TEXT 和 BLOB
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;TEXT 可以存储更长的字符串，即长文本数据，例如博客内容。&lt;/li&gt;
&lt;li&gt;BLOB 类型主要用于存储二进制大对象，例如图片、音视频等文件。&lt;/li&gt;
&lt;li&gt;TEXT 和 BLOB 缺点：
&lt;ul&gt;
&lt;li&gt;不能有默认值。&lt;/li&gt;
&lt;li&gt;检索效率较低。&lt;/li&gt;
&lt;li&gt;在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表。&lt;/li&gt;
&lt;li&gt;不能直接创建索引，需要指定前缀长度。
&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-1.png&#34;
	width=&#34;990&#34;
	height=&#34;449&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-1_hu_dada62f7d2c52a32.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-1_hu_423eb2c7607370a0.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;220&#34;
		data-flex-basis=&#34;529px&#34;
	
&gt; &amp;gt; &lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-2.png&#34;
	width=&#34;999&#34;
	height=&#34;457&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-2_hu_8d460f34bb7ae061.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-2_hu_5cff2a90b8be2234.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;218&#34;
		data-flex-basis=&#34;524px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;datetime-和-timestamp&#34;&gt;&lt;a href=&#34;#datetime-%e5%92%8c-timestamp&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;DATETIME 和 TIMESTAMP
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html#%E6%97%B6%E5%8C%BA%E4%BF%A1%E6%81%AF&#34;  title=&#34;MySQL日期类型选择建议 | JavaGuide&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL 日期类型选择建议 | JavaGuide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。
&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-3.png&#34;
	width=&#34;1594&#34;
	height=&#34;614&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-3_hu_38c6b5a7aa80305.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-3_hu_618882815bdb491b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;259&#34;
		data-flex-basis=&#34;623px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;null-和的区别&#34;&gt;&lt;a href=&#34;#null-%e5%92%8c%e7%9a%84%e5%8c%ba%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;NULL 和&amp;quot;&amp;ldquo;的区别
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NULL&lt;/code&gt; 代表一个不确定的值,就算是两个 &lt;code&gt;NULL&lt;/code&gt;,它俩也不一定相等。例如，&lt;code&gt;SELECT NULL=NULL&lt;/code&gt;的结果为 NULL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;&#39;&lt;/code&gt;的长度是 0，是不占用空间的，而&lt;code&gt;NULL&lt;/code&gt; 是需要占用空间&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;为什么-mysql-不建议使用-null-作为列默认值&#34;&gt;&lt;a href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88-mysql-%e4%b8%8d%e5%bb%ba%e8%ae%ae%e4%bd%bf%e7%94%a8-null-%e4%bd%9c%e4%b8%ba%e5%88%97%e9%bb%98%e8%ae%a4%e5%80%bc&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;为什么 MySQL 不建议使用 &lt;code&gt;NULL&lt;/code&gt; 作为列默认值?
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt; 会影响聚合函数的结果。例如，&lt;code&gt;SUM&lt;/code&gt;、&lt;code&gt;AVG&lt;/code&gt;、&lt;code&gt;MIN&lt;/code&gt;、&lt;code&gt;MAX&lt;/code&gt; 等聚合函数会忽略 &lt;code&gt;NULL&lt;/code&gt; 值，如果参数是某个字段名(&lt;code&gt;COUNT(列名)&lt;/code&gt;)，则会忽略 &lt;code&gt;NULL&lt;/code&gt; 值，只统计非空值的个数。查询 &lt;code&gt;NULL&lt;/code&gt; 值时，必须使用 &lt;code&gt;IS NULL&lt;/code&gt; 或 &lt;code&gt;IS NOT NULLl&lt;/code&gt; 来判断，而不能使用 =、!=、 &amp;lt;、&amp;gt; 之类的比较运算符。而&lt;code&gt;&#39;&#39;&lt;/code&gt;是可以使用这些比较运算符的。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;boolean-类型如何表示&#34;&gt;&lt;a href=&#34;#boolean-%e7%b1%bb%e5%9e%8b%e5%a6%82%e4%bd%95%e8%a1%a8%e7%a4%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Boolean 类型如何表示
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;mysql-基础架构&#34;&gt;&lt;a href=&#34;#mysql-%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;MySQL 基础架构
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-4.png&#34;
	width=&#34;1437&#34;
	height=&#34;1088&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-4_hu_703d27ddae52e213.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-4_hu_a495e2d79e84f504.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;132&#34;
		data-flex-basis=&#34;316px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连接器：&lt;/strong&gt; 身份认证和权限相关(登录 MySQL 的时候)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查询缓存：&lt;/strong&gt; 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分析器：&lt;/strong&gt; 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化器：&lt;/strong&gt; 按照 MySQL 认为最优的方案去执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行器：&lt;/strong&gt; 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插件式存储引擎&lt;/strong&gt; ：主要负责数据的存储和读取，采用的是&lt;strong&gt;插件式架构&lt;/strong&gt;，支持 InnoDB、MyISAM、Memory 等多种存储引擎。InnoDB 是 MySQL 的默认存储引擎，绝大部分场景使用 InnoDB 就是最好的选择。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;mysql-存储引擎&#34;&gt;&lt;a href=&#34;#mysql-%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;MySQL 存储引擎
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html&#34;  title=&#34;MySQL :: MySQL 8.0 Reference Manual :: 17 The InnoDB Storage Engine&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL :: MySQL 8.0 Reference Manual :: 17 The InnoDB Storage Engine&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html&#34;  title=&#34;MySQL :: MySQL 8.0 Reference Manual :: 18 Alternative Storage Engines&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL :: MySQL 8.0 Reference Manual :: 18 Alternative Storage Engines&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-5.png&#34;
	width=&#34;2152&#34;
	height=&#34;538&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-5_hu_2c6352c126711b07.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-5_hu_58ed7189f3e90260.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;400&#34;
		data-flex-basis=&#34;960px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。 在上述所有引擎中，&lt;strong&gt;只有 InnoDB 引擎支持事务。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;上面还提到过 MySQL 存储引擎采用的是 &lt;strong&gt;插件式架构&lt;/strong&gt; ，支持多种存储引擎。&lt;strong&gt;存储引擎是基于表的，而不是数据库。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;myisam-和-innodb-区别&#34;&gt;&lt;a href=&#34;#myisam-%e5%92%8c-innodb-%e5%8c%ba%e5%88%ab&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;MyISAM 和 InnoDB 区别
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;锁：&lt;/strong&gt; MyISAM 只有表级锁，而 InnoDB 支持行级锁和表级锁，默认为行级锁。对于并发操作，细粒度的行级锁性能肯定更好！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事务：&lt;/strong&gt;
MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了四个隔离级别，分别是：&lt;strong&gt;读未提交、读已提交、可重复读、可串行化&lt;/strong&gt;。InnoDB 默认是可重读，隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;外键：&lt;/strong&gt; MyISAM 不支持物理外键，而 InnoDB 支持物理外键。然而外键的维护对数据库性能也有一定影响，特别是分布式、高并发项目，一个字段的更新往往会引起其他字段的更新，极大拉低数据库性能，因此是不建议使用物理外键，而是逻辑外键（在代码中进行约束）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据恢复&lt;/strong&gt; ：MyISAM 不支持，而 InnoDB 支持。使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候依赖&lt;strong&gt;redo.log&lt;/strong&gt;使数据库恢复到崩溃前的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MVCC：&lt;/strong&gt; MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。MyISAM 显然是不支持 MVCC 的，毕竟连行级锁都没有。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;索引：&lt;/strong&gt; 都使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据缓存策略和机制：&lt;/strong&gt; InnoDB 使用缓冲池（Buffer Pool）缓存数据页和索引页，MyISAM 使用键缓存（Key Cache）仅缓存索引页而不缓存数据页。当数据库对数据做修改的时候，需要把数据页从磁盘读到 buffer pool 中，&lt;strong&gt;然后在 buffer pool 中进行修改&lt;/strong&gt; ，此时 buffer pool 中的数据页就与磁盘上的数据页&lt;strong&gt;内容不一致&lt;/strong&gt;，如果这个时候发生 DB 服务重启，那么这些数据并没有同步到磁盘文件中（同步到磁盘文件是个随机 IO），就会发生数据丢失，如果这个时候，能够在有一个文件，当 buffer pool 中的数据页变更结束后，把相应修改记录记录到这个文件（记录日志是顺序 IO），那么当 DB 服务进行恢复 DB 的时候，可以根据这个文件的记录内容，重新持久化刷新到磁盘文件，保持数据的一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能：&lt;/strong&gt; InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的&lt;strong&gt;读写能力呈线性增长&lt;/strong&gt;。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-6.png&#34;
	width=&#34;1606&#34;
	height=&#34;549&#34;
	srcset=&#34;/zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-6_hu_66e9c13c13f7c56c.png 480w, /zh-cn/post/2024/12/mysql%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/image-6_hu_41924396b50195ff.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;292&#34;
		data-flex-basis=&#34;702px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;mysql-如何存储-ip-地址&#34;&gt;&lt;a href=&#34;#mysql-%e5%a6%82%e4%bd%95%e5%ad%98%e5%82%a8-ip-%e5%9c%b0%e5%9d%80&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;MySQL 如何存储 IP 地址
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;可以使用字符串存储，但是存储空间相对较大（每个字符占用 1 字节），每个 IP 占用空间为 7-15 个字节（1.1.1.1 占用 7 字节，100.100.100.100 占用 15 字节）。&lt;/p&gt;
&lt;p&gt;对于 ipv4，其实是 4 字节 32 位的数字，可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。&lt;/p&gt;
&lt;p&gt;MySQL 提供了两个方法来处理 ip 地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;INET_ATON()&lt;/code&gt;：把 ip 转为无符号整型 (4-8 位)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INET_NTOA()&lt;/code&gt; :把整型的 ip 转为地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;插入数据前，先用 &lt;code&gt;INET_ATON()&lt;/code&gt; 把 ip 地址转为整型，显示数据时，使用 &lt;code&gt;INET_NTOA()&lt;/code&gt; 把整型的 ip 地址转为地址显示即可。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
