<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>RabbitMQ on 青秋博客</title>
        <link>/zh-cn/categories/rabbitmq/</link>
        <description>Recent content in RabbitMQ on 青秋博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>青秋博客</copyright>
        <lastBuildDate>Fri, 05 Sep 2025 12:39:19 +0000</lastBuildDate><atom:link href="/zh-cn/categories/rabbitmq/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>kafka、RabbitMQ结构</title>
        <link>/zh-cn/post/2025/09/kafkarabbitmq%E7%BB%93%E6%9E%84/</link>
        <pubDate>Fri, 05 Sep 2025 12:39:19 +0000</pubDate>
        
        <guid>/zh-cn/post/2025/09/kafkarabbitmq%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;h2 id=&#34;kafka-实现结构&#34;&gt;&lt;a href=&#34;#kafka-%e5%ae%9e%e7%8e%b0%e7%bb%93%e6%9e%84&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Kafka 实现结构
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Apache Kafka&lt;/strong&gt; 是一个分布式流处理平台，主要用于构建实时数据管道和流式应用程序。以下是 Kafka 的主要实现结构：&lt;/p&gt;
&lt;h3 id=&#34;producer&#34;&gt;&lt;a href=&#34;#producer&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Producer
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;生产者将消息发送到指定 Topic 中或指定 Partition。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;broker&#34;&gt;&lt;a href=&#34;#broker&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Broker
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Kafka 集群由多个 Broker 组成，每个 Broker 是一个 Kafka 服务节点。&lt;/li&gt;
&lt;li&gt;一个 Topic 有多个 Partition，每个 Partition 有多个副本，存储在不同的 Broker 上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;consumer&#34;&gt;&lt;a href=&#34;#consumer&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Consumer
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;消费者可以组成消费者组，从 Kafka 的主题中读取消息，每个某分区仅能由消费者组中的一个消费者消费，防止重复消费并保证消息有序性。&lt;/li&gt;
&lt;li&gt;消费者通过 Offset 来记录消费进度，确保消息的顺序消费。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;topic&#34;&gt;&lt;a href=&#34;#topic&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Topic
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;主题是 Kafka 中消息的分类单位，生产者将消息发送到特定的主题。&lt;/li&gt;
&lt;li&gt;每个主题可以有多个分区，分区是 Kafka 实现高吞吐量和可扩展性的关键。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;partition&#34;&gt;&lt;a href=&#34;#partition&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Partition
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;分区是主题的逻辑分片，每个分区是一个&lt;strong&gt;有序的&lt;/strong&gt;、不可变的消息序列。&lt;/li&gt;
&lt;li&gt;分区提高了 Kafka 的并发能力和数据存储能力，因为多个分区可以分布在不同的 Broker 上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;offset&#34;&gt;&lt;a href=&#34;#offset&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Offset
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;偏移量是消费者在分区中读取消息的位置标记。&lt;/li&gt;
&lt;li&gt;消费者通过提交偏移量来记录消费进度，确保在故障恢复时能够从上次消费的位置继续消费。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;zookeeper&#34;&gt;&lt;a href=&#34;#zookeeper&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Zookeeper
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Kafka 使用 Zookeeper 来管理集群元数据，如主题、分区、Broker 的状态等。&lt;/li&gt;
&lt;li&gt;Zookeeper 用于协调 Kafka 集群中的各个节点，确保集群的高可用性和一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rabbitmq-实现结构&#34;&gt;&lt;a href=&#34;#rabbitmq-%e5%ae%9e%e7%8e%b0%e7%bb%93%e6%9e%84&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;RabbitMQ 实现结构
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;  基于 AMQP 协议实现。以下是 RabbitMQ 的主要实现结构：&lt;/p&gt;
&lt;h3 id=&#34;producer-1&#34;&gt;&lt;a href=&#34;#producer-1&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Producer
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;生产者是消息的发送方，负责将消息发送到 RabbitMQ 的交换器（Exchange）。&lt;/li&gt;
&lt;li&gt;生产者在发送消息时，通常会指定一个路由键（Routing Key）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;exchange&#34;&gt;&lt;a href=&#34;#exchange&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Exchange
&lt;/h3&gt;&lt;p&gt;交换器是消息的分发中心，负责将消息路由到一个或多个队列。RabbitMQ 提供了四种类型的交换器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Direct Exchange&lt;/strong&gt;：将消息路由到与路由键完全匹配的队列。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fanout Exchange&lt;/strong&gt;：将消息广播到所有与交换器绑定的队列，忽略路由键。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Topic Exchange&lt;/strong&gt;：根据通配符匹配路由键，将消息路由到一个或多个队列。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Headers Exchange&lt;/strong&gt;：根据消息头中的属性进行匹配，将消息路由到与消息头匹配的队列。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;queue&#34;&gt;&lt;a href=&#34;#queue&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Queue
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;队列是消息的存储区，用于存储生产者发送的消息。&lt;/li&gt;
&lt;li&gt;消费者从队列中读取消息并处理。&lt;/li&gt;
&lt;li&gt;队列可以绑定到一个或多个交换器，通过绑定键（Binding Key）来指定消息的路由规则。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;consumer-1&#34;&gt;&lt;a href=&#34;#consumer-1&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Consumer
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;消费者从队列中读取消息并处理。&lt;/li&gt;
&lt;li&gt;消费者可以通过手动或自动确认机制（ACK）来确认消息的处理结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;binding&#34;&gt;&lt;a href=&#34;#binding&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Binding
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;绑定是交换器和队列之间的关联关系，通过绑定键（Binding Key）来指定消息的路由规则。&lt;/li&gt;
&lt;li&gt;一个交换器可以绑定到多个队列，一个队列也可以绑定到多个交换器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;routing-key&#34;&gt;&lt;a href=&#34;#routing-key&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Routing Key
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;路由键是生产者在发送消息时指定的字符串，用于交换器确定消息的路由规则。&lt;/li&gt;
&lt;li&gt;路由键需要与交换器类型和绑定键联合使用才能最终生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;virtual-host&#34;&gt;&lt;a href=&#34;#virtual-host&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Virtual Host
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;虚拟主机是 RabbitMQ 中的逻辑隔离单元，每个虚拟主机都有一套自己的交换器和队列。&lt;/li&gt;
&lt;li&gt;不同的用户可以在同一个 RabbitMQ 实例中创建自己的虚拟主机，实现资源隔离。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;connection-和-channel&#34;&gt;&lt;a href=&#34;#connection-%e5%92%8c-channel&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;Connection 和 Channel
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Connection&lt;/strong&gt;：客户端与 RabbitMQ 服务器之间的 TCP 连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Channel&lt;/strong&gt;：在 Connection 上创建的虚拟连接，用于减少创建 TCP 连接的数量。&lt;/li&gt;
&lt;li&gt;一个 Connection 可以创建多个 Channel，每个 Channel 都是独立的双向数据流通道。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;&lt;a href=&#34;#%e6%80%bb%e7%bb%93&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;总结
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Kafka&lt;/strong&gt; 主要用于高吞吐量、分布式的消息处理，适合大规模数据流的实时处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt; 提供了丰富的消息路由功能，适合复杂的业务逻辑和多种消息分发模式。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
