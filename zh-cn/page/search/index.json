[{"content":"\n","date":"2025-07-27T00:00:00Z","permalink":"/zh-cn/post/2025/07/2025%E6%9C%80%E6%96%B0%E4%BD%BF%E7%94%A8github-action%E9%83%A8%E7%BD%B2hugo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E8%87%AA%E6%9C%89%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE/","title":"2025最新，使用Github Action部署hugo个人博客+自有域名配置"},{"content":" 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n","date":"2025-06-02T00:14:03+08:00","image":"/zh-cn/post/2025/06/test2/img_hu_73276912b0d5557f.png","permalink":"/zh-cn/post/2025/06/test2/","title":"Test2"},{"content":" 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\n","date":"2025-06-02T00:14:03+08:00","image":"/zh-cn/post/2025/06/test3/img_hu_73276912b0d5557f.png","permalink":"/zh-cn/post/2025/06/test3/","title":"Test3"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"/zh-cn/post/2023/09/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"/zh-cn/post/2023/08/image-gallery/2_hu_3e58a979f20e4e46.jpg","permalink":"/zh-cn/post/2023/08/image-gallery/","title":"Image gallery"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"/zh-cn/post/2023/08/shortcodes/cover_hu_5667347daefb4230.jpg","permalink":"/zh-cn/post/2023/08/shortcodes/","title":"Shortcodes"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ 1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"/zh-cn/post/2023/08/math-typesetting/","title":"Math Typesetting"},{"content":"引导图 正文 数组指针 先不讨论什么是数组指针，举个例子\n1 2 3 4 5 6 7 int* p1; //p1是整型指针，它指向的是整型，指针类型是int* char* p2; //p2是字符指针，它指向的是字符，指针类型是char* AI生成项目cpp 运行 注意！！！为什么我写成了 int* p1 而不是 int *p1，其实两种写法都可以，只不过为了方便理解，把 int*看成一种类似于 int，char，float 的变量类型，同理 char*也是如此，后文不再阐述。\nSo 数组指针就是指向数组的指针！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int arr[5]={1,2,3,4,5}; //数组名arr相当于数组首元素arr[0]的地址,+1跨越了一个数组元素 //但是有一个例外，sizeof(数组名)计算的是整个数组的大小，而非一个数组元素的大小 //\u0026amp;arr才是数组真正的地址，+1跨越了一个数组 int (*parr)[5];//取数组地址\u0026amp;arr赋给数组指针parr //因为*parr是带括号的！！所以*parr一体，所以把*parr拿掉，剩下int [5]，左边表示元素类型int，右边表示元素个数[5]，这就是数组指针的本质。 //具体如何理解呢？ //因为原数组arr有5个元素，所以数组指针parr指向的数组元素个数也得为5，写作[5], 就好比5个人乘车，车上必须有5个座位，如果有4个，总不能一个人坐车顶吧。 //而且，原数组arr元素皆为int，所以数组指针为int型， 那么在上句的基础上写作int [5]，最后再加上(*parr),就有了int (*parr)[5]。 当然，若原数组arr元素为int*,那么数组指针写成int* (*parr)[5]; AI生成项目cpp 运行 记住，它只是一个数组指针，只负责指向一个数组，至于数组的元素类型是 int 还是 int*，元素个数是[5]还是[6],都是它所指向的数组决定的，而非指针决定，以下所有内容均可这样理解。至于为何写成（*parr）而不是*parr，这和符号优先级有关，看完下文的“指针数组”就明白了~\n1.1.数组指针作为形参接收二维数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void test1(int arr[][3]) {函数体} void test2(int (*parr)[3]) { for(int i=0;i\u0026lt;2;i++) { for(int j=0;j\u0026lt;3;j++) { printf(\u0026#34;%d \u0026#34;,*(*(parr+i)+j)); } printf(\u0026#34;\\n\u0026#34;); } void test3(int* arr) {函数体} void test4(int* arr[3]) {函数体} void test5(int** arr) {函数体} int main() { int arr[2][3]={{9，8，7},{6，5，4}}; test1(arr); //√ test2(arr); //√ test3(arr); //× test4(arr); //× test5(arr); //× } AI生成项目cpp 运行 test1 中，二维数组作形参接收二维数组参数，没毛病；在 test2 中，首先要说明的是，二维数组作为参数传参，传过去的是二维数组的第一行的地址（看个人理解），也就是 parr 里面放的是{9，8，7}这个一维数组的地址。我们让其+i 就是第 i 行的地址，然后*（parr+i），把第 i 行的地址取出来，再+j，此时得到第 i 行的第 j 个元素的地址(*(parr+i)+j)，再对其解引用*(*(parr+i)+j)得到第 i 行第 j 个元素的值。至于 test3，形参是整型指针，而实参是一个一维数组的地址，要用数组指针接收才行，错。test4，形参是整型指针数组，用来接收整型指针，而我们的实参是一维数组地址，驴唇不对马嘴，pass。test5，形参是二级指针，用来接收一级指针变量的地址或者二级指针，同样驴唇不对马嘴，pass。\n指针数组 同上，先不讨论什么是指针数组，举个例子\n1 2 3 4 5 6 7 int arr1[5]={1,2,3,4,5}; //这是 整型 数组，存放整型元素 char arr2[5]={\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;}; //这是 字符 数组，存放字符型元素 AI生成项目cpp 运行 So 指针数组就是存放指针的数组！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int arr[5]={1,2,3,4,5}; int* p; int m; char* k; int* parr[3]={arr,p,\u0026amp;m}; //* parr没有带括号！！那么只把parr拿掉，只剩int* [3],和数组指针一样，左边表示元素类型int*，右边表示元素个数[3],这是指针数组的本质。 //当然还可以写成int* [4],只要≥3就行，因为parr至少要存放3个元素 //注意！！！ k是字符型指针，无法存放到整型指针数组中 //如何理解？ //首先，arr和\u0026amp;m是地址，p是指针，一共3个元素全放到指针数组parr里，就有了元素个数[3] //其次，arr和\u0026amp;m以及p都是int*(注意，m是int，\u0026amp;m取了地址就是int*，而arr本身就是地址)，所以指针数组元素类型为int*，于是有了int* [3],数组取名为parr AI生成项目cpp 运行 没错，只要是 int*类型的都可以放到数组 parr 里，因为 parr 就是存放整型指针的数组。\n不用管数组 arr 里面几个元素，我们已经在 parr 里面放了数组 arr 的首元素地址，那么就可以借此访问数组 arr 的所有元素。\n指向指针数组的数组指针 顾名思义，这是一个数组指针，只不过它指向的是指针数组，而这个数组里面存放的是指针。\n它长个什么样呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //6个指针数组的元素 int *p0,*p1,*p2; int p3，p4; int p5[]={7,8,9，10}; //2个指针数组 int *pa[3]={p0,\u0026amp;p3,p5}; int *pb[3]={p1,p2 ,\u0026amp;p4}; //OK,接下来我要用 数组指针 指着这俩 指针数组 ~ int* (pc[2])[3]={pa,pb};//pc就是指向指针数组的数组指针 //如何理解呢？ //首先pc[2]带了括号，那就把pc[2]拿掉，剩下int* [3],这不就是个指针数组吗？左边元素类型int*，右边数组元素个数[3]. //当然可以写成int* [4],总之\u0026gt;=3就行，因为数组pa和pb元素个数都为3，至少得放得下3个 //如果再加上pc[2]，那就是说明我有俩指针pc[0]和pc[1],分别指向两个数组pa和pb，pa和pb各有3个元素 //当然pc[2]可以写成pc[3],只要\u0026gt;=2就行，因为数组指针pc至少要指向2个指针数组pa和pb AI生成项目cpp 运行 存放数组指针的指针数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //2个数组 int p1[3]={4,5,6}; int p5[3]={7,8,9}; //2个数组指针 int (*pa)[3]=p1; int (*pb)[3]=p5; //1个指针数组存放2个数组指针 int* (pc[2])[3]={pa,pb};//pc就是存放数组指针的指针数组 //如何理解？ //老规矩，pc[2]带了括号，是一体的，把pc[2]拿掉，剩下int* [3], //左边就是元素类型int*，右边是数组指针指向的数组的元素个数[3]， //当然还可以写成int* [4],总之\u0026gt;=3就行，因为数组p1和p5最多3个元素，至少得放得下3个； //同理pc[2]可以写成pc[3]，\u0026gt;=2就行，因为至少要存放2个数组指针pa和pb。 AI生成项目cpp 运行 函数指针 函数指针作形参接收参数 先看看这个 qsort 函数，是 C 语言库函数之一，用于对任何元素类型的数组排序。它有 4 个形参，第一个是要排序数组的地址，第二个是数组元素个数，第三个是数组元素的字节大小，也就是跨越一个元素的步长，第四个就是本节重点，一个函数指针，用来接收数组排序所需的排序函数，比如冒泡，选择排序\u0026hellip;\nOK，请看下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;stdio.h\u0026gt; int add(int x,int y) { return x+y;} int sub(int x,int y) { return x-y;} int Calc(int (*p)(int,int))//函数指针作为形参接收函数地址 { int x=0,y=0; printf(\u0026#34;请输入两个操作数:\u0026gt;\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;x,\u0026amp;y); return (*p)(x,y);//p(x,y)也可以 } int main() { int ret=Calc(add);//把add函数地址传过去，用函数指针接收 printf(\u0026#34;加法运算 %d\\n\u0026#34;,ret);//结果是8 ret=Calc(sub); printf(\u0026#34;减法运算 %d\\n\u0026#34;,ret);//结果是-2 return 0; } AI生成项目cpp 运行 运算结果如下：\n这就是函数指针。。。\n函数指针接收函数地址 如图：函数名本身就是函数的地址，和\u0026amp;函数名效果相同，*ptr 说明其是指针，int （*ptr）说明函数的返回值是 int，而(int , int)则是函数 add 的形参。当然，函数指针也可以和数组指针一样放在指针数组中，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int add(int x,int y) { return x+y;} int sub(int x,int y) { return x-y;} int main() { int (*p1)(int,int)=add; int (*p2)(int,int)=sub; int (*p[2])(int ,int)={p1,p2};//两个函数指针放到函数指数组里 (*p1)(3,5);//结果是8 (*p2)(3,5);//结果是-2 } AI生成项目cpp 运行 当然我还可以再找一个指针指向这个函数指针数组，然后把这个指针再放到指针数组里，这样无限套娃\u0026hellip;..\n玩点好玩的 1 2 3 (* (void(*)()) 0)() AI生成项目cpp 运行 这个出自《C 语言陷阱与缺陷》这本书，作用是调用首地址为 0 地址的子例程。首先 0，用(void(*)()) ，把它转化成函数指针，也就是(void(*)()) 0，然后对这个函数指针调用（* (void(*)()) 0) ( ),显然形参为空。看解释：\n1 2 3 4 5 6 7 8 //调用0地址处的函数 //该函数无参，返回类型是void //1.void(*) () ---函数指针类型 //2.(void(*) ()) 0 ---对0强制类型转化，成为一个函数地址 //3.*(void(*) ()) 0 ---我TM直接对地址解引用 //4.(*(void(*) ()) 0) () ---调用0地址处的函数 AI生成项目cpp 运行 OK，本文到此为止，NND 写了我四五个小时\u0026hellip;.\n","date":"2023-08-04T16:08:31Z","image":"/zh-cn/post/2023/08/c-%E6%8C%87%E9%92%88%E8%BF%9B%E9%98%B6--%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8F%8A%E4%BC%A0%E5%8F%82/cover_hu_e95a4276bf860a84.jpg","permalink":"/zh-cn/post/2023/08/c-%E6%8C%87%E9%92%88%E8%BF%9B%E9%98%B6--%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8F%8A%E4%BC%A0%E5%8F%82/","title":"C 指针进阶--数组指针 指针数组 函数指针及传参"}]